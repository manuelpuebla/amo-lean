/**
 * Poseidon2 S-box Implementation
 * Generated by AMO-Lean Phase Poseidon (Paso 2.1)
 *
 * Field: BN254 (254-bit prime field)
 * State size: 3
 * S-box exponent: 5
 * Square chain multiplications: 3
 *
 * This is SCALAR code - optimized SIMD versions are in separate files.
 * See ADR-004 for the layered CodeGen strategy.
 */

#ifndef POSEIDON_SBOX_H
#define POSEIDON_SBOX_H

#include <stdint.h>
#include <stddef.h>

#ifdef __cplusplus
extern "C" {
#endif

/* ============================================================================
 * Type Definitions
 * ============================================================================ */

/**
 * Poseidon state with 3 field elements
 */
typedef struct {
    uint64_t elem[3][4];
} poseidon_state_3;

/**
 * Field parameters (for Montgomery arithmetic)
 */
typedef struct {
    uint64_t modulus[4];  // Prime modulus
    uint64_t r2[4];       // R^2 mod p (for Montgomery)
    uint64_t inv;         // -p^(-1) mod 2^64
} field_params;

/* ============================================================================
 * Field Multiplication (External - implement in field_ops.c)
 * ============================================================================ */

/**
 * Field multiplication with Montgomery reduction
 * out = a * b mod p
 */
extern void field_mul(uint64_t *out, const uint64_t *a, const uint64_t *b,
                      const field_params *p);

/* ============================================================================
 * S-box Implementation
 * ============================================================================ */

/**
 * S-box: x^5 using optimal square chain (3 multiplications)
 * Generated by AMO-Lean Phase Poseidon (Paso 2.1)
 *
 * @param out  Output field element
 * @param x    Input field element
 * @param p    Field parameters (modulus, Montgomery constants)
 */
static inline void sbox5(
    uint64_t *out,
    const uint64_t *x,
    const field_params *p
) {
    /* PROOF_ANCHOR: PRE: x is valid field element */
    uint64_t x2[4];
    uint64_t x4[4];

    field_mul(x2, x, x, p);    // x2 = x * x
    field_mul(x4, x2, x2, p);  // x4 = x2 * x2
    field_mul(out, x, x4, p);  // res = x * x4
    /* PROOF_ANCHOR: POST: out = x^5 mod p */
}

/* ============================================================================
 * Full Round S-box (all state elements)
 * ============================================================================ */

/**
 * Full round S-box: apply x^5 to all 3 state elements
 * Used in first RF/2 and last RF/2 rounds of Poseidon2
 *
 * @param state  Poseidon state (modified in place)
 * @param p      Field parameters
 */
void sbox5_full_round(
    poseidon_state_3 *state,
    const field_params *p
) {
    /* PROOF_ANCHOR: PRE: state contains valid field elements */
    for (int i = 0; i < 3; i++) {
        sbox5(state->elem[i], state->elem[i], p);
    }
    /* PROOF_ANCHOR: POST: state[i] = state[i]^exp for all i */
}

/* ============================================================================
 * Partial Round S-box (first element only)
 * ============================================================================ */

/**
 * Partial round S-box: apply x^5 only to state[0]
 * Used in middle RP rounds of Poseidon2
 *
 * @param state  Poseidon state (modified in place)
 * @param p      Field parameters
 */
void sbox5_partial_round(
    poseidon_state_3 *state,
    const field_params *p
) {
    /* PROOF_ANCHOR: PRE: state contains valid field elements */
    sbox5(state->elem[0], state->elem[0], p);
    /* PROOF_ANCHOR: POST: state[0] = state[0]^exp, state[1..t-1] unchanged */
}

#ifdef __cplusplus
}
#endif

#endif // POSEIDON_SBOX_H
