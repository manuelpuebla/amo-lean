/**
 * Poseidon2 S-box Implementation - BN254 Batch SIMD
 * Generated by AMO-Lean Phase Poseidon (Paso 2.4)
 *
 * Field: BN254 (254-bit prime field)
 * State size: 3
 * S-box exponent: 5
 * Batch size: 4 independent hashes in parallel
 *
 * Optimization: Inter-hash SIMD - process 4 hashes simultaneously.
 * Since BN254 elements are 254 bits, we can't fit multiple elements
 * in one SIMD register. Instead, we process corresponding limbs from
 * 4 different hashes in parallel.
 *
 * See ADR-004 for the layered CodeGen strategy.
 */

#ifndef POSEIDON_SBOX_BN254_BATCH_H
#define POSEIDON_SBOX_BN254_BATCH_H

#include <stdint.h>
#include <string.h>
#include <immintrin.h>  // AVX2 intrinsics

#ifdef __cplusplus
extern "C" {
#endif

/* ============================================================================
 * Field Parameters (same as scalar version)
 * ============================================================================ */

typedef struct {
    uint64_t modulus[4];
    uint64_t r2[4];
    uint64_t inv;
} field_params;

/* ============================================================================
 * Batch Data Structures for BN254
 *
 * For 254-bit fields, one element fills an entire YMM register.
 * To use SIMD, we process 4 independent hashes in parallel.
 * ============================================================================ */

/**
 * Array of Structures (AoS): User-facing layout
 * Each hash has t field elements, each element has 4 limbs.
 */
typedef struct {
    uint64_t hash[4][3][4];  // [hash_idx][elem_idx][limb_idx]
} batch4_aos_3;

/**
 * Structure of Arrays (SoA): SIMD-friendly internal layout
 * Each limb position contains data from all 4 hashes.
 *
 * Layout for element i, limb j:
 *   __m256i contains [hash0.elem[i].limb[j] | hash1... | hash2... | hash3...]
 */
typedef struct {
    __m256i elem[3][4];  // [elem_idx][limb_idx] = 4 hashes worth
} batch4_soa_3;

/* ============================================================================
 * AoS ↔ SoA Transpose Functions
 * ============================================================================ */

/**
 * Transpose from AoS to SoA layout.
 * This enables SIMD operations across corresponding limbs of 4 hashes.
 *
 * @param out  SoA output (SIMD-friendly)
 * @param in   AoS input (user-facing)
 */
static inline void batch4_aos_to_soa_3(
    batch4_soa_3 *out,
    const batch4_aos_3 *in
) {
    /* PROOF_ANCHOR: PRE: in contains 4 valid hash states */

    for (int e = 0; e < 3; e++) {          // For each state element
        for (int l = 0; l < 4; l++) {        // For each limb
            /* Gather limb l of element e from all 4 hashes */
            out->elem[e][l] = _mm256_set_epi64x(
                in->hash[3][e][l],  // hash 3, element e, limb l
                in->hash[2][e][l],  // hash 2
                in->hash[1][e][l],  // hash 1
                in->hash[0][e][l]   // hash 0
            );
        }
    }

    /* PROOF_ANCHOR: POST: out.elem[e][l] = [h3.e.l | h2.e.l | h1.e.l | h0.e.l] */
}

/**
 * Transpose from SoA back to AoS layout.
 *
 * @param out  AoS output (user-facing)
 * @param in   SoA input (SIMD-friendly)
 */
static inline void batch4_soa_to_aos_3(
    batch4_aos_3 *out,
    const batch4_soa_3 *in
) {
    /* PROOF_ANCHOR: PRE: in contains valid SIMD batch state */

    for (int e = 0; e < 3; e++) {
        for (int l = 0; l < 4; l++) {
            /* Scatter limb l of element e to all 4 hashes */
            uint64_t limbs[4];
            _mm256_storeu_si256((__m256i*)limbs, in->elem[e][l]);
            out->hash[0][e][l] = limbs[0];
            out->hash[1][e][l] = limbs[1];
            out->hash[2][e][l] = limbs[2];
            out->hash[3][e][l] = limbs[3];
        }
    }

    /* PROOF_ANCHOR: POST: out.hash[h][e][l] = in.elem[e][l][h] for all h,e,l */
}

/* ============================================================================
 * Batch Field Multiplication
 * ============================================================================ */

/**
 * Batch field multiplication for BN254 (4 independent multiplications).
 *
 * This performs 4 parallel 256-bit Montgomery multiplications.
 * Each multiplication is: (a * b * R^-1) mod p
 *
 * Strategy: Process corresponding limbs from all 4 hashes together.
 * The Montgomery reduction uses limb-by-limb operations.
 *
 * @param out    Output: 4 products (SoA format, 4 limbs)
 * @param a      Input a: 4 field elements (SoA format)
 * @param b      Input b: 4 field elements (SoA format)
 * @param p      Field parameters (modulus, Montgomery constant)
 */
static inline void batch4_field_mul(
    __m256i out[4],
    const __m256i a[4],
    const __m256i b[4],
    const field_params *p
) {
    /* PROOF_ANCHOR: PRE: a[i], b[i] are valid field elements in Montgomery form */

    /* Accumulator for 512-bit intermediate product (8 limbs) */
    __m256i prod[8] = {
        _mm256_setzero_si256(), _mm256_setzero_si256(),
        _mm256_setzero_si256(), _mm256_setzero_si256(),
        _mm256_setzero_si256(), _mm256_setzero_si256(),
        _mm256_setzero_si256(), _mm256_setzero_si256()
    };

    /* Broadcast modulus and Montgomery constant */
    __m256i mod[4], inv;
    for (int i = 0; i < 4; i++) {
        mod[i] = _mm256_set1_epi64x(p->modulus[i]);
    }
    inv = _mm256_set1_epi64x(p->inv);

    /* Schoolbook multiplication: O(n^2) limb multiplications */
    for (int i = 0; i < 4; i++) {
        for (int j = 0; j < 4; j++) {
            /* Multiply a[i] * b[j] for all 4 hashes */
            __m256i a_limb = a[i];
            __m256i b_limb = b[j];

            /* 64-bit * 64-bit -> 128-bit product per lane */
            __m256i lo = _mm256_mul_epu32(a_limb, b_limb);
            __m256i a_hi = _mm256_srli_epi64(a_limb, 32);
            __m256i b_hi = _mm256_srli_epi64(b_limb, 32);
            __m256i mid1 = _mm256_mul_epu32(a_limb, b_hi);
            __m256i mid2 = _mm256_mul_epu32(a_hi, b_limb);
            __m256i hi = _mm256_mul_epu32(a_hi, b_hi);

            /* Combine partial products */
            __m256i mid = _mm256_add_epi64(mid1, mid2);
            __m256i mid_lo = _mm256_slli_epi64(mid, 32);
            __m256i mid_hi = _mm256_srli_epi64(mid, 32);

            lo = _mm256_add_epi64(lo, mid_lo);
            hi = _mm256_add_epi64(hi, mid_hi);

            /* Accumulate into product limb [i+j] and [i+j+1] */
            prod[i + j] = _mm256_add_epi64(prod[i + j], lo);
            prod[i + j + 1] = _mm256_add_epi64(prod[i + j + 1], hi);
        }
    }

    /* Montgomery reduction (simplified - full impl would handle carries) */
    /* For production: implement proper carry propagation */

    /* Extract lower 4 limbs as result (simplified) */
    out[0] = prod[0];
    out[1] = prod[1];
    out[2] = prod[2];
    out[3] = prod[3];

    /* TODO: Full Montgomery reduction with modular subtraction */
    /* This is a placeholder - production code needs proper reduction */

    /* PROOF_ANCHOR: POST: out = a * b * R^-1 mod p (Montgomery form) */
}

/* ============================================================================
 * Batch S-box Implementation
 * ============================================================================ */

/**
 * Batch S-box x^5 for BN254 (4 independent hashes).
 *
 * Processes 4 hashes in parallel using the square chain.
 * Each hash's state element is stored in SoA format (4 limbs).
 *
 * @param out    Output field element (SoA: 4 limbs, each __m256i holds 4 hashes)
 * @param x      Input field element (SoA format)
 * @param p      Field parameters
 */
static inline void batch4_sbox5(
    __m256i out[4],
    const __m256i x[4],
    const field_params *p
) {
    /* PROOF_ANCHOR: PRE: x is valid field element in Montgomery form */

    __m256i x2[4], x4[4];

    /* x^2 = x * x */
    batch4_field_mul(x2, x, x, p);

    /* x^4 = x^2 * x^2 */
    batch4_field_mul(x4, x2, x2, p);

    /* x^5 = x * x^4 */
    batch4_field_mul(out, x, x4, p);

    /* PROOF_ANCHOR: POST: out = x^5 mod p (Montgomery form) */
}

/* ============================================================================
 * Batch Full Round S-box
 * ============================================================================ */

/**
 * Batch full round S-box: apply x^5 to all 3 elements of 4 hashes.
 *
 * @param state  Batch state in SoA format (modified in place)
 * @param p      Field parameters
 */
static inline void batch4_sbox5_full_round_3(
    batch4_soa_3 *state,
    const field_params *p
) {
    /* PROOF_ANCHOR: PRE: state contains 4 valid hash states */

    for (int e = 0; e < 3; e++) {
        batch4_sbox5(state->elem[e], state->elem[e], p);
    }

    /* PROOF_ANCHOR: POST: state.elem[e] = old_state.elem[e]^5 for all e */
}

/* ============================================================================
 * Batch Partial Round S-box
 * ============================================================================ */

/**
 * Batch partial round S-box: apply x^5 only to element 0 of 4 hashes.
 *
 * @param state  Batch state in SoA format (modified in place)
 * @param p      Field parameters
 */
static inline void batch4_sbox5_partial_round_3(
    batch4_soa_3 *state,
    const field_params *p
) {
    /* PROOF_ANCHOR: PRE: state contains 4 valid hash states */

    /* Only apply S-box to element 0 */
    batch4_sbox5(state->elem[0], state->elem[0], p);

    /* PROOF_ANCHOR: POST: state.elem[0] = old_state.elem[0]^5, others unchanged */
}

/* ============================================================================
 * Public Batch API
 * ============================================================================ */

/**
 * Public API: Apply S-box to 4 independent hash states (full round).
 *
 * This is the user-facing function that:
 * 1. Transposes AoS → SoA
 * 2. Applies S-box in parallel
 * 3. Transposes SoA → AoS
 *
 * @param states  4 hash states (modified in place)
 * @param p       Field parameters
 */
void poseidon2_sbox5_full_round_batch4(
    batch4_aos_3 *states,
    const field_params *p
) {
    /* PROOF_ANCHOR: PRE: states contains 4 valid hash states */

    /* Transpose to SIMD-friendly layout */
    batch4_soa_3 soa;
    batch4_aos_to_soa_3(&soa, states);

    /* Apply S-box to all elements */
    batch4_sbox5_full_round_3(&soa, p);

    /* Transpose back to user layout */
    batch4_soa_to_aos_3(states, &soa);

    /* PROOF_ANCHOR: POST: states[h].elem[e] = old_states[h].elem[e]^5 for all h,e */
}

/**
 * Public API: Apply S-box to 4 independent hash states (partial round).
 *
 * @param states  4 hash states (modified in place)
 * @param p       Field parameters
 */
void poseidon2_sbox5_partial_round_batch4(
    batch4_aos_3 *states,
    const field_params *p
) {
    /* PROOF_ANCHOR: PRE: states contains 4 valid hash states */

    /* Transpose to SIMD-friendly layout */
    batch4_soa_3 soa;
    batch4_aos_to_soa_3(&soa, states);

    /* Apply S-box only to element 0 */
    batch4_sbox5_partial_round_3(&soa, p);

    /* Transpose back to user layout */
    batch4_soa_to_aos_3(states, &soa);

    /* PROOF_ANCHOR: POST: states[h].elem[0] transformed, others unchanged */
}

#ifdef __cplusplus
}
#endif

#endif // POSEIDON_SBOX_BN254_BATCH_H
