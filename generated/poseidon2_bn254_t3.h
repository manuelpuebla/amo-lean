/**
 * Poseidon2 Complete Implementation
 * Generated by AMO-Lean Phase 3
 *
 * Configuration:
 *   Field: AmoLean.Protocols.Poseidon.MatExpr.PoseidonField.BN254
 *   State size: t=3
 *   S-box: x^5
 *   Rounds: RF=8, RP=56
 *   MDS optimization: true
 *
 * Estimated multiplications per hash:
 *   536
 */

#ifndef POSEIDON2_H
#define POSEIDON2_H

#include <stdint.h>
#include <string.h>

#ifdef __cplusplus
extern "C" {
#endif

/* ============================================================================
 * Type Definitions
 * ============================================================================ */

typedef struct {
    uint64_t elem[3][4];
} poseidon_state_3;

typedef struct {
    uint64_t modulus[4];
    uint64_t r2[4];
    uint64_t inv;
} field_params;

/* ============================================================================
 * External Constants (defined in poseidon_constants.c)
 * ============================================================================ */

extern const uint64_t POSEIDON_MDS[3][3][4];
extern const uint64_t POSEIDON_MDS_DIAG[3][4];
extern const uint64_t POSEIDON_RC[64][3][4];

/* ============================================================================
 * Field Operations (defined in field_ops.c)
 * ============================================================================ */

extern void field_add(uint64_t *out, const uint64_t *a, const uint64_t *b,
                      const field_params *p);
extern void field_mul(uint64_t *out, const uint64_t *a, const uint64_t *b,
                      const field_params *p);
extern void field_zero(uint64_t *out);

/* ============================================================================
 * S-box Implementation
 * ============================================================================ */

static inline void sbox5(
    uint64_t *out,
    const uint64_t *x,
    const field_params *p
) {
    uint64_t x2[4], x4[4];
    field_mul(x2, x, x, p);      // x^2
    field_mul(x4, x2, x2, p);    // x^4
    field_mul(out, x, x4, p);    // x^5
}

/* ============================================================================
 * Round Functions
 * ============================================================================ */

static inline void poseidon_full_round(
    poseidon_state_3 *state,
    int round,
    const field_params *p
) {
    // Add round constants
    for (int i = 0; i < 3; i++) {
        field_add(state->elem[i], state->elem[i], POSEIDON_RC[round][i], p);
    }

    // S-box on all elements
    for (int i = 0; i < 3; i++) {
        sbox5(state->elem[i], state->elem[i], p);
    }

    // MDS matrix multiplication
    poseidon_state_3 tmp;
    for (int i = 0; i < 3; i++) {
        field_zero(tmp.elem[i]);
        for (int j = 0; j < 3; j++) {
            uint64_t prod[4];
            field_mul(prod, POSEIDON_MDS[i][j], state->elem[j], p);
            field_add(tmp.elem[i], tmp.elem[i], prod, p);
        }
    }
    memcpy(state, &tmp, sizeof(tmp));
}

static inline void poseidon_partial_round(
    poseidon_state_3 *state,
    int round,
    const field_params *p
) {
    // Add round constants
    for (int i = 0; i < 3; i++) {
        field_add(state->elem[i], state->elem[i], POSEIDON_RC[round][i], p);
    }

    // S-box on element 0 only
    sbox5(state->elem[0], state->elem[0], p);

    // MDS internal (Poseidon2: diagonal + low-rank)
    // Sum all elements
    uint64_t sum[4];
    field_zero(sum);
    for (int i = 0; i < 3; i++) {
        field_add(sum, sum, state->elem[i], p);
    }
    // Apply: state[i] = state[i] * diag[i] + sum
    for (int i = 0; i < 3; i++) {
        uint64_t scaled[4];
        field_mul(scaled, state->elem[i], POSEIDON_MDS_DIAG[i], p);
        field_add(state->elem[i], scaled, sum, p);
    }
}

/* ============================================================================
 * Permutation
 * ============================================================================ */

/**
 * Poseidon2 Permutation
 * Field: AmoLean.Protocols.Poseidon.MatExpr.PoseidonField.BN254
 * State size: 3
 * Rounds: RF=8, RP=56
 *
 * Structure: [RF/2 full] → [RP partial] → [RF/2 full]
 */
void poseidon2_permutation(
    poseidon_state_3 *state,
    const field_params *p
) {
    int round = 0;

    // First RF/2 full rounds
    for (int r = 0; r < 4; r++) {
        poseidon_full_round(state, round++, p);
    }

    // RP partial rounds
    for (int r = 0; r < 56; r++) {
        poseidon_partial_round(state, round++, p);
    }

    // Last RF/2 full rounds
    for (int r = 0; r < 4; r++) {
        poseidon_full_round(state, round++, p);
    }
}

/* ============================================================================
 * Hash Function (Sponge Construction)
 * ============================================================================ */

/**
 * Hash two field elements (for Merkle tree)
 */
static inline void poseidon2_hash_2to1(
    uint64_t out[4],
    const uint64_t left[4],
    const uint64_t right[4],
    const field_params *p
) {
    poseidon_state_3 state;
    memset(&state, 0, sizeof(state));

    // Absorb left and right
    memcpy(state.elem[0], left, 32);
    memcpy(state.elem[1], right, 32);

    // Permute
    poseidon2_permutation(&state, p);

    // Squeeze first element
    memcpy(out, state.elem[0], 32);
}

#ifdef __cplusplus
}
#endif

#endif // POSEIDON2_H
