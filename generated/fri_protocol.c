/*
 * FRI Protocol Implementation
 * Generated by AMO-Lean Phase 7-Alpha
 *
 * Field: Goldilocks (p = 2^64 - 2^32 + 1)
 * SIMD: Scalar only (for portability)
 *
 * This file is generated from CryptoSigma IR and includes:
 * - Proof anchors documenting pre/postconditions
 * - Security-critical operation ordering preserved
 * - BARRIER markers for non-reorderable operations
 */

#include <stdint.h>
#include <stddef.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

// Field element type (Goldilocks: p = 2^64 - 2^32 + 1)
typedef uint64_t field_t;

// Goldilocks prime
#define GOLDILOCKS_P 0xFFFFFFFF00000001ULL

// Transcript state for Fiat-Shamir
typedef struct {
    field_t state[4];      // Sponge state (simplified)
    size_t absorb_count;   // Number of elements absorbed
    size_t squeeze_count;  // Number of challenges squeezed
} transcript_t;

// ============================================================================
// PROOF_ANCHOR: transcript_init
// Preconditions:
//   - ts != NULL
// Postconditions:
//   - ts->absorb_count == 0
//   - ts->squeeze_count == 0
//   - ts->state is initialized
// ============================================================================
void transcript_init(transcript_t* ts) {
    memset(ts, 0, sizeof(transcript_t));
}

// ============================================================================
// PROOF_ANCHOR: transcript_absorb
// Preconditions:
//   - ts != NULL, data != NULL
//   - count > 0
// Postconditions:
//   - ts->state updated with absorbed data
//   - ts->absorb_count incremented by count
// Invariants:
//   - BARRIER: No code motion across this operation
//   - FIAT-SHAMIR: data incorporated into challenge derivation
// ============================================================================
void transcript_absorb(transcript_t* ts, const field_t* data, size_t count) {
    // BARRIER - compiler must not reorder
    __asm__ volatile("" ::: "memory");

    for (size_t i = 0; i < count; i++) {
        // Simple sponge simulation: XOR into state
        ts->state[ts->absorb_count % 4] ^= data[i];
        ts->absorb_count++;
    }

    __asm__ volatile("" ::: "memory");
}

// ============================================================================
// PROOF_ANCHOR: transcript_squeeze
// Preconditions:
//   - ts != NULL
//   - ts->absorb_count > 0 (at least one absorb since last squeeze)
// Postconditions:
//   - Returns pseudo-random field element
//   - ts->squeeze_count incremented
// Invariants:
//   - BARRIER: No code motion across this operation
//   - SECURITY: Challenge depends on ALL previously absorbed data
// ============================================================================
field_t transcript_squeeze(transcript_t* ts) {
    // BARRIER
    __asm__ volatile("" ::: "memory");

    // Simple hash: combine state elements with squeeze count
    field_t challenge = ts->state[0] ^ ts->state[1] ^ ts->state[2] ^ ts->state[3];
    challenge ^= (field_t)ts->squeeze_count;
    challenge = (challenge * 0x9e3779b97f4a7c15ULL) ^ (challenge >> 32);

    ts->squeeze_count++;

    __asm__ volatile("" ::: "memory");

    return challenge;
}

// ============================================================================
// PROOF_ANCHOR: merkle_hash
// Preconditions:
//   - left and right are valid field elements
// Postconditions:
//   - Returns hash(left, right)
//   - Hash is collision-resistant (in real impl)
// ============================================================================
field_t merkle_hash(field_t left, field_t right) {
    // Simplified hash for testing (real impl would use Poseidon, etc.)
    field_t combined = left ^ (right * 0x9e3779b97f4a7c15ULL);
    combined ^= (combined >> 33);
    combined *= 0xff51afd7ed558ccdULL;
    combined ^= (combined >> 33);
    return combined;
}

// ============================================================================
// PROOF_ANCHOR: fri_fold
// Preconditions:
//   - n > 0
//   - input has 2*n elements
//   - output has n elements
//   - input != output (no aliasing)
// Postconditions:
//   - forall i in [0, n): output[i] == input[2*i] + alpha * input[2*i + 1]
// Invariants:
//   - Memory accesses are contiguous
//   - Suitable for SIMD vectorization
// ============================================================================
void fri_fold(size_t n, const field_t* input, field_t* output, field_t alpha) {
    for (size_t i = 0; i < n; i++) {
        output[i] = input[2*i] + alpha * input[2*i + 1];
    }
}

// ============================================================================
// PROOF_ANCHOR: merkle_build
// Preconditions:
//   - n is a power of 2
//   - leaves has n elements
//   - nodes has 2*n - 1 elements
// Postconditions:
//   - nodes[0..n-1] == leaves[0..n-1]
//   - forall layer k: nodes at layer k are hashes of children at layer k-1
//   - nodes[2*n - 2] is the Merkle root
// Invariants:
//   - Bottom-up construction
//   - Layer-by-layer hashing
// ============================================================================
void merkle_build(size_t n, const field_t* leaves, field_t* nodes) {
    // Copy leaves to first n positions
    memcpy(nodes, leaves, n * sizeof(field_t));

    // Build tree bottom-up
    size_t layer_start = 0;
    size_t layer_size = n;

    while (layer_size > 1) {
        size_t next_start = layer_start + layer_size;
        size_t next_size = layer_size / 2;

        for (size_t i = 0; i < next_size; i++) {
            size_t left_idx = layer_start + 2 * i;
            size_t right_idx = layer_start + 2 * i + 1;
            size_t parent_idx = next_start + i;
            nodes[parent_idx] = merkle_hash(nodes[left_idx], nodes[right_idx]);
        }

        layer_start = next_start;
        layer_size = next_size;
    }
}

// ============================================================================
// PROOF_ANCHOR: fri_round
// Preconditions:
//   - poly has domain_size elements
//   - transcript is valid
// Postconditions:
//   - Merkle commitment computed and absorbed
//   - Challenge alpha squeezed from transcript
//   - output_poly has domain_size/2 elements
//   - output_poly[i] == poly[2*i] + alpha * poly[2*i + 1]
// Invariants:
//   - SECURITY: commit BEFORE squeeze (Fiat-Shamir)
//   - Order: Commit → Absorb → Squeeze → Fold
// ============================================================================
field_t fri_round(
    size_t domain_size,
    const field_t* poly,
    field_t* output_poly,
    field_t* merkle_nodes,
    transcript_t* transcript
) {
    // === DOMAIN ENTER: FRI_FOLD ===

    // Phase 1: COMMIT - Build Merkle tree
    // === DOMAIN ENTER: MERKLE_NODE ===
    merkle_build(domain_size, poly, merkle_nodes);
    field_t root = merkle_nodes[2 * domain_size - 2];
    // === DOMAIN EXIT ===

    // Phase 2: ABSORB - Ingest root into transcript
    // BARRIER: Security-critical ordering
    transcript_absorb(transcript, &root, 1);

    // Phase 3: SQUEEZE - Extract challenge
    // BARRIER: Must come after absorb
    field_t alpha = transcript_squeeze(transcript);

    // Phase 4: FOLD - Compute next layer
    fri_fold(domain_size / 2, poly, output_poly, alpha);

    // === DOMAIN EXIT ===

    return alpha;
}

// ============================================================================
// PROOF_ANCHOR: fri_commit_phase
// Preconditions:
//   - initial_poly has initial_size elements
//   - num_rounds > 0
//   - All allocated buffers are properly sized
// Postconditions:
//   - commitments[] contains num_rounds Merkle roots
//   - challenges[] contains num_rounds alpha values
//   - final_poly has initial_size / 2^num_rounds elements
// Security Invariants:
//   - Each round: commit BEFORE squeeze
//   - All roots absorbed before any challenge derived
// ============================================================================
void fri_commit_phase(
    size_t initial_size,
    size_t num_rounds,
    const field_t* initial_poly,
    field_t* final_poly,
    field_t* commitments,
    field_t* challenges,
    transcript_t* transcript
) {
    // Allocate working buffer
    field_t* work_buffer = (field_t*)malloc(initial_size * sizeof(field_t));
    memcpy(work_buffer, initial_poly, initial_size * sizeof(field_t));

    // Merkle tree nodes (worst case: 2*initial_size)
    field_t* merkle_nodes = (field_t*)malloc(2 * initial_size * sizeof(field_t));

    const field_t* current = work_buffer;
    field_t* next = final_poly;
    size_t domain = initial_size;

    for (size_t round = 0; round < num_rounds; round++) {
        // Execute round
        field_t alpha = fri_round(domain, current, next, merkle_nodes, transcript);

        // Store results
        commitments[round] = merkle_nodes[2 * domain - 2];
        challenges[round] = alpha;

        // Prepare for next round
        if (round + 1 < num_rounds) {
            // Swap buffers
            const field_t* temp = current;
            current = next;
            next = (field_t*)temp;
        }
        domain /= 2;
    }

    // Ensure final result is in final_poly
    if (current != final_poly) {
        memcpy(final_poly, current, domain * sizeof(field_t));
    }

    free(merkle_nodes);
    free(work_buffer);
}

// ============================================================================
// Test harness for differential testing
// ============================================================================
#ifdef FRI_TEST_MAIN

#include <stdlib.h>

void print_array(const char* name, const field_t* arr, size_t n) {
    printf("%s: [", name);
    for (size_t i = 0; i < n; i++) {
        printf("%llu", (unsigned long long)arr[i]);
        if (i < n - 1) printf(", ");
    }
    printf("]\n");
}

int main() {
    printf("=== FRI Protocol Differential Test ===\n\n");

    // Test configuration
    const size_t N = 16;  // Initial domain size
    const size_t NUM_ROUNDS = 2;

    // Allocate arrays
    field_t initial_poly[N];
    field_t final_poly[N / 4];  // After 2 rounds: N/4
    field_t commitments[NUM_ROUNDS];
    field_t challenges[NUM_ROUNDS];

    // Initialize polynomial with test values
    printf("Initial polynomial (degree %zu):\n", N);
    for (size_t i = 0; i < N; i++) {
        initial_poly[i] = i + 1;  // Simple values: 1, 2, 3, ...
    }
    print_array("P0", initial_poly, N);

    // Initialize transcript
    transcript_t transcript;
    transcript_init(&transcript);

    // Run FRI commit phase
    printf("\n--- Running FRI Commit Phase (%zu rounds) ---\n", NUM_ROUNDS);
    fri_commit_phase(N, NUM_ROUNDS, initial_poly, final_poly, commitments, challenges, &transcript);

    // Print results
    printf("\nResults:\n");
    for (size_t r = 0; r < NUM_ROUNDS; r++) {
        printf("  Round %zu: commitment=0x%016llx, alpha=0x%016llx\n",
               r, (unsigned long long)commitments[r], (unsigned long long)challenges[r]);
    }

    printf("\nFinal polynomial (degree %zu):\n", N / (1 << NUM_ROUNDS));
    print_array("P_final", final_poly, N / (1 << NUM_ROUNDS));

    // Output for differential testing
    printf("\n=== DIFFERENTIAL_TEST_OUTPUT ===\n");
    printf("INITIAL_SIZE=%zu\n", N);
    printf("NUM_ROUNDS=%zu\n", NUM_ROUNDS);
    for (size_t r = 0; r < NUM_ROUNDS; r++) {
        printf("COMMITMENT_%zu=%llu\n", r, (unsigned long long)commitments[r]);
        printf("CHALLENGE_%zu=%llu\n", r, (unsigned long long)challenges[r]);
    }
    printf("FINAL_SIZE=%zu\n", N / (1 << NUM_ROUNDS));
    for (size_t i = 0; i < N / (1 << NUM_ROUNDS); i++) {
        printf("FINAL_%zu=%llu\n", i, (unsigned long long)final_poly[i]);
    }
    printf("=== END_OUTPUT ===\n");

    return 0;
}

#endif // FRI_TEST_MAIN
