/**
 * Poseidon2 S-box Implementation - Goldilocks AVX2 SIMD
 * Generated by AMO-Lean Phase Poseidon (Paso 2.3)
 *
 * Field: Goldilocks (p = 2^64 - 2^32 + 1)
 * State size: 12
 * S-box exponent: 7
 * SIMD width: 4 elements per YMM register
 *
 * Optimization: Intra-hash SIMD - 4 state elements processed in parallel.
 * See ADR-004 for the layered CodeGen strategy.
 */

#ifndef POSEIDON_SBOX_GOLDILOCKS_SIMD_H
#define POSEIDON_SBOX_GOLDILOCKS_SIMD_H

#include <stdint.h>
#include <immintrin.h>  // AVX2 intrinsics

#ifdef __cplusplus
extern "C" {
#endif

/* ============================================================================
 * Goldilocks Field Constants
 * ============================================================================ */

/* Goldilocks prime: p = 2^64 - 2^32 + 1 */
#define GOLDILOCKS_PRIME 0xFFFFFFFF00000001ULL
#define GOLDILOCKS_EPSILON 0xFFFFFFFFULL  // 2^32 - 1

/* Broadcast prime and epsilon to all lanes */
static const __m256i GOLDILOCKS_P_VEC = {
    GOLDILOCKS_PRIME, GOLDILOCKS_PRIME, GOLDILOCKS_PRIME, GOLDILOCKS_PRIME
};
static const __m256i GOLDILOCKS_EPSILON_VEC = {
    GOLDILOCKS_EPSILON, GOLDILOCKS_EPSILON, GOLDILOCKS_EPSILON, GOLDILOCKS_EPSILON
};

/* ============================================================================
 * AVX2 Field Multiplication
 * ============================================================================ */

/**
 * Vectorized field multiplication for Goldilocks (4 elements in parallel)
 * Uses the fact that p = 2^64 - 2^32 + 1 allows fast reduction.
 *
 * For a * b mod p:
 * 1. Compute full 128-bit product for each lane
 * 2. Split into high and low 64-bit parts
 * 3. Apply Goldilocks reduction: (hi * 2^64 + lo) mod p = (lo - hi * epsilon) mod p
 *
 * @param a  4 field elements
 * @param b  4 field elements
 * @return   4 products a[i] * b[i] mod p
 */
static inline __m256i field_mul_avx2(__m256i a, __m256i b) {
    /* PROOF_ANCHOR: PRE: a[i], b[i] < p for all i */

    /* Multiply low 32 bits to get partial products */
    __m256i lo_lo = _mm256_mul_epu32(a, b);  // a[31:0] * b[31:0]

    /* Shift to get high 32 bits of each 64-bit element */
    __m256i a_hi = _mm256_srli_epi64(a, 32);
    __m256i b_hi = _mm256_srli_epi64(b, 32);

    /* Cross products */
    __m256i lo_hi = _mm256_mul_epu32(a, b_hi);     // a[31:0] * b[63:32]
    __m256i hi_lo = _mm256_mul_epu32(a_hi, b);     // a[63:32] * b[31:0]
    __m256i hi_hi = _mm256_mul_epu32(a_hi, b_hi);  // a[63:32] * b[63:32]

    /* Accumulate: result = lo_lo + (lo_hi + hi_lo) << 32 + hi_hi << 64 */
    __m256i mid = _mm256_add_epi64(lo_hi, hi_lo);
    __m256i mid_lo = _mm256_slli_epi64(mid, 32);
    __m256i mid_hi = _mm256_srli_epi64(mid, 32);

    /* Low 64 bits of product */
    __m256i prod_lo = _mm256_add_epi64(lo_lo, mid_lo);

    /* High 64 bits of product */
    __m256i prod_hi = _mm256_add_epi64(hi_hi, mid_hi);

    /* Handle carry from prod_lo addition */
    __m256i carry = _mm256_srli_epi64(_mm256_cmpgt_epi64(lo_lo, prod_lo), 63);
    prod_hi = _mm256_sub_epi64(prod_hi, carry);  // Adjust for borrow semantics

    /* Goldilocks reduction: (prod_hi * 2^64 + prod_lo) mod p
     * = prod_lo - prod_hi * epsilon + prod_hi (when prod_hi * epsilon < 2^64)
     * For simplicity, use iterative reduction */
    __m256i epsilon_prod = _mm256_mul_epu32(prod_hi, GOLDILOCKS_EPSILON_VEC);
    __m256i result = _mm256_sub_epi64(prod_lo, epsilon_prod);
    result = _mm256_add_epi64(result, prod_hi);

    /* Final reduction: if result >= p, subtract p */
    __m256i overflow = _mm256_cmpgt_epi64(result, GOLDILOCKS_P_VEC);
    result = _mm256_sub_epi64(result, _mm256_and_si256(overflow, GOLDILOCKS_P_VEC));

    /* PROOF_ANCHOR: POST: result[i] = a[i] * b[i] mod p for all i */
    return result;
}

/* ============================================================================
 * AVX2 S-box Implementation
 * ============================================================================ */

/**
 * Vectorized S-box x^7 for Goldilocks (4 elements in parallel)
 * Uses optimal square chain with 4 multiplications per element.
 *
 * @param x  4 field elements
 * @return   4 results x[i]^7 mod p
 */
static inline __m256i sbox7_simd(__m256i x) {
    /* PROOF_ANCHOR: PRE: x[i] < p for all i */
    __m256i x2 = field_mul_avx2(x, x);      // x^2
    __m256i x4 = field_mul_avx2(x2, x2);    // x^4
    __m256i x5 = field_mul_avx2(x, x4);     // x^5
    /* PROOF_ANCHOR: POST: result[i] = x[i]^7 mod p for all i */
    return x5;
}

/* ============================================================================
 * AVX2 Partial S-box with Blend
 * ============================================================================ */

/**
 * Partial round S-box: apply x^7 only to lane 0, keep lanes 1-3 unchanged.
 * Uses AVX2 blend to combine results efficiently.
 *
 * @param state  4 field elements (state[0] will be transformed)
 * @return       state with state[0] = state[0]^7, others unchanged
 */
static inline __m256i sbox7_partial_simd(__m256i state) {
    /* PROOF_ANCHOR: PRE: state[i] < p for all i */

    /* Compute S-box for all lanes (speculative) */
    __m256i x5_all = sbox7_simd(state);

    /* Blend: keep lanes 1,2,3 from original state, take lane 0 from x5_all
     * Blend mask 0b1110 = 14 means:
     *   lane 0: from x5_all (bit 0 = 0)
     *   lane 1: from state  (bit 1 = 1)
     *   lane 2: from state  (bit 2 = 1)
     *   lane 3: from state  (bit 3 = 1)
     */
    __m256i result = _mm256_blend_epi64(x5_all, state, 0b1110);

    /* PROOF_ANCHOR: POST: result[0] = state[0]^7, result[i] = state[i] for i > 0 */
    return result;
}

/* ============================================================================
 * Full Round S-box (SIMD)
 * ============================================================================ */

/**
 * Full round S-box using AVX2: apply x^7 to all 12 state elements.
 * Processes 4 elements per SIMD operation.
 *
 * @param state  Poseidon state array (must be 32-byte aligned)
 */
static inline void sbox7_full_round_simd(uint64_t *state) {
    /* PROOF_ANCHOR: PRE: state[i] < p for all i in [0, 12) */
    /* PROOF_ANCHOR: REQUIRE: state is 32-byte aligned */

    /* Process 4 elements at a time */
    for (int i = 0; i < 12; i += 4) {
        __m256i vec = _mm256_load_si256((__m256i*)(state + i));
        __m256i result = sbox7_simd(vec);
        _mm256_store_si256((__m256i*)(state + i), result);
    }

    /* PROOF_ANCHOR: POST: state[i] = old_state[i]^7 mod p for all i */
}

/* ============================================================================
 * Partial Round S-box (SIMD)
 * ============================================================================ */

/**
 * Partial round S-box using AVX2: apply x^7 only to state[0].
 * Uses speculative computation and blend for efficiency.
 *
 * @param state  Poseidon state array (must be 32-byte aligned)
 */
static inline void sbox7_partial_round_simd(uint64_t *state) {
    /* PROOF_ANCHOR: PRE: state[i] < p for all i in [0, 12) */
    /* PROOF_ANCHOR: REQUIRE: state is 32-byte aligned */

    /* Load first 4 elements */
    __m256i vec = _mm256_load_si256((__m256i*)state);

    /* Apply partial S-box (only transforms lane 0) */
    __m256i result = sbox7_partial_simd(vec);

    /* Store back */
    _mm256_store_si256((__m256i*)state, result);

    /* PROOF_ANCHOR: POST: state[0] = old_state[0]^7, state[i] unchanged for i > 0 */
}

#ifdef __cplusplus
}
#endif

#endif // POSEIDON_SBOX_GOLDILOCKS_SIMD_H
