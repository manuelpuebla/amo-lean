<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>AMO-Lean Plan Unificado</title>
  <style>
    /* Default styles provided by pandoc.
    ** See https://pandoc.org/MANUAL.html#variables-for-html for config info.
    */
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
    /* CSS for syntax highlighting */
    html { -webkit-text-size-adjust: 100%; }
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@5/github-markdown.min.css" />
</head>
<body>
<header id="title-block-header">
<h1 class="title">AMO-Lean Plan Unificado</h1>
</header>
<h1 id="amo-lean-plan-unificado-de-desarrollo">AMO-Lean: Plan Unificado
de Desarrollo</h1>
<p><strong>Documento de Diseño y Roadmap</strong>
<strong>Versión:</strong> 1.0 <strong>Fecha:</strong> 2026-01-29
<strong>Estado:</strong> Aprobado</p>
<hr />
<h2 id="qué-es-amo-lean">1. Qué es AMO-Lean</h2>
<h3 id="definición">1.1 Definición</h3>
<p><strong>AMO-Lean</strong> = <em>Automatic Mathematical Optimizer in
Lean</em></p>
<p>AMO-Lean es un <strong>optimizador formal</strong> que utiliza el
conocimiento de estructuras matemáticas para transformar
especificaciones en código optimizado con garantías de corrección.</p>
<h3 id="la-visión-optimización-formal">1.2 La Visión: “Optimización
Formal”</h3>
<pre><code>┌─────────────────────────────────────────────────────────────────┐
│                                                                 │
│   Especificación       Conocimiento          Código             │
│   Matemática      →    Matemático       →    Optimizado         │
│   (Lean DSL)           Formal                (C/Rust)           │
│                        (Teoremas)            Correcto por       │
│                                              Construcción       │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘</code></pre>
<p><strong>Diferenciador clave:</strong> - Un compilador tradicional
optimiza basándose en <strong>patrones sintácticos</strong> - AMO-Lean
optimiza basándose en <strong>propiedades matemáticas
verificadas</strong></p>
<h3 id="qué-no-es-amo-lean">1.3 Qué NO es AMO-Lean</h3>
<table>
<thead>
<tr>
<th>NO es</th>
<th>Explicación</th>
</tr>
</thead>
<tbody>
<tr>
<td>Compilador de Lean arbitrario</td>
<td>Solo trabaja con su DSL específico</td>
</tr>
<tr>
<td>Una zkVM</td>
<td>Es una herramienta que zkVMs pueden usar</td>
</tr>
<tr>
<td>Librería criptográfica</td>
<td>Es un optimizador/verificador</td>
</tr>
<tr>
<td>Competidor de Plonky3</td>
<td>Lo complementa</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="arquitectura-unificada">2. Arquitectura Unificada</h2>
<h3 id="dos-funcionalidades-principales">2.1 Dos Funcionalidades
Principales</h3>
<p>AMO-Lean tendrá <strong>dos modos de operación</strong> que comparten
una base común:</p>
<table>
<colgroup>
<col style="width: 22%" />
<col style="width: 29%" />
<col style="width: 48%" />
</colgroup>
<thead>
<tr>
<th>Modo</th>
<th>Nombre</th>
<th>Descripción</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>B</strong></td>
<td>Verificador</td>
<td>Certifica que optimizaciones externas (ej: Plonky3) son
correctas</td>
</tr>
<tr>
<td><strong>C</strong></td>
<td>Generador</td>
<td>Produce código optimizado (ej: NTT) con pruebas de corrección</td>
</tr>
</tbody>
</table>
<h3 id="diagrama-de-arquitectura">2.2 Diagrama de Arquitectura</h3>
<pre><code>┌─────────────────────────────────────────────────────────────────────────┐
│                        AMO-Lean Arquitectura                             │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│                      ┌─────────────────────┐                            │
│                      │    CORE COMÚN       │                            │
│                      │    (Compartido)     │                            │
│                      │                     │                            │
│                      │ • Specs Formales    │                            │
│                      │ • Teoremas (Mathlib)│                            │
│                      │ • E-Graph Engine    │                            │
│                      │ • Verified Rules    │                            │
│                      └──────────┬──────────┘                            │
│                                 │                                       │
│                    ┌────────────┴────────────┐                          │
│                    │                         │                          │
│           ┌────────▼────────┐       ┌────────▼────────┐                 │
│           │   MODO B        │       │   MODO C        │                 │
│           │  (Verificador)  │       │  (Generador)    │                 │
│           │                 │       │                 │                 │
│           │ • Parser externo│       │ • CodeGen C     │                 │
│           │ • Mapping rules │       │ • CodeGen Rust  │                 │
│           │ • Certificados  │       │ • Backends SIMD │                 │
│           └─────────────────┘       └─────────────────┘                 │
│                    │                         │                          │
│                    ▼                         ▼                          │
│           &quot;Plonky3 verified         &quot;amolean-ntt&quot;                       │
│            by AMO-Lean&quot;              (crate Rust)                       │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘</code></pre>
<h3 id="por-qué-esta-arquitectura">2.3 Por Qué Esta Arquitectura</h3>
<table>
<thead>
<tr>
<th>Beneficio</th>
<th>Explicación</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Reutilización</strong></td>
<td>~60% del código es compartido entre B y C</td>
</tr>
<tr>
<td><strong>Flexibilidad</strong></td>
<td>Usuarios eligen verificar o generar</td>
</tr>
<tr>
<td><strong>Valor único</strong></td>
<td>B complementa Plonky3, C compite en NTT verificada</td>
</tr>
<tr>
<td><strong>Escalabilidad</strong></td>
<td>Más componentes se agregan igual</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="modo-b-verificador-de-optimizaciones">3. Modo B: Verificador de
Optimizaciones</h2>
<h3 id="concepto">3.1 Concepto</h3>
<p>En lugar de generar código desde cero, AMO-Lean
<strong>certifica</strong> que las optimizaciones de proyectos
existentes (como Plonky3) son matemáticamente correctas.</p>
<h3 id="flujo-de-trabajo">3.2 Flujo de Trabajo</h3>
<pre><code>┌──────────────┐      ┌─────────────────────┐      ┌──────────────┐
│   Plonky3    │      │    AMO-Lean         │      │ Certificado  │
│   (código)   │ ──▶  │                     │ ──▶  │              │
│              │      │ 1. Parsea regla     │      │ &quot;Regla X es  │
│ optimización │      │ 2. Mapea a teorema  │      │  sound bajo  │
│     X        │      │ 3. Verifica prueba  │      │  axiomas Y&quot;  │
└──────────────┘      └─────────────────────┘      └──────────────┘</code></pre>
<h3 id="ejemplo-concreto">3.3 Ejemplo Concreto</h3>
<p><strong>Plonky3 tiene esta optimización:</strong></p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Reducción Goldilocks: usa 2^64 ≡ 2^32 - 1 (mod p)</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> reduce128(x<span class="op">:</span> <span class="dt">u128</span>) <span class="op">-&gt;</span> <span class="dt">u64</span> <span class="op">{</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> (lo<span class="op">,</span> hi) <span class="op">=</span> (x <span class="kw">as</span> <span class="dt">u64</span><span class="op">,</span> (x <span class="op">&gt;&gt;</span> <span class="dv">64</span>) <span class="kw">as</span> <span class="dt">u64</span>)<span class="op">;</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> hi_lo <span class="op">=</span> hi <span class="op">&amp;</span> <span class="dv">0xFFFFFFFF</span><span class="op">;</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> hi_hi <span class="op">=</span> hi <span class="op">&gt;&gt;</span> <span class="dv">32</span><span class="op">;</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ... reducción usando la identidad</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><strong>AMO-Lean certifica:</strong></p>
<pre class="lean"><code>theorem goldilocks_reduce_correct (x : UInt128) :
    reduce128 x % GOLDILOCKS_P = x % GOLDILOCKS_P := by
  -- Prueba usando 2^64 ≡ EPSILON (mod p)
  simp [reduce128, GOLDILOCKS_P, EPSILON]
  ring</code></pre>
<h3 id="entregables-del-modo-b">3.4 Entregables del Modo B</h3>
<table>
<thead>
<tr>
<th>Entregable</th>
<th>Descripción</th>
</tr>
</thead>
<tbody>
<tr>
<td>Framework de mapping</td>
<td>Conecta código externo → teoremas</td>
</tr>
<tr>
<td>Formalización Plonky3 Goldilocks</td>
<td>Reglas de campo verificadas</td>
</tr>
<tr>
<td>Formalización Plonky3 NTT</td>
<td>Cooley-Tukey verificado</td>
</tr>
<tr>
<td>Generador de certificados</td>
<td>Documentos legibles</td>
</tr>
<tr>
<td>CI de re-verificación</td>
<td>Automático en cada release</td>
</tr>
</tbody>
</table>
<h3 id="valor-del-modo-b">3.5 Valor del Modo B</h3>
<ul>
<li><strong>No compite con Plonky3</strong> - lo complementa</li>
<li><strong>Aumenta confianza</strong> - “optimizaciones matemáticamente
verificadas”</li>
<li><strong>Único en el mercado</strong> - nadie más ofrece esto</li>
</ul>
<hr />
<h2 id="modo-c-generador-de-código-verificado">4. Modo C: Generador de
Código Verificado</h2>
<h3 id="concepto-1">4.1 Concepto</h3>
<p>Construir componentes que sean: 1. <strong>Formalmente
especificados</strong> en Lean 2. <strong>Implementados con
optimizaciones</strong> derivadas de propiedades matemáticas 3.
<strong>Usables</strong> desde C y Rust via FFI</p>
<h3 id="componente-principal-ntt-verificada">4.2 Componente Principal:
NTT Verificada</h3>
<pre><code>┌─────────────────────────────────────────────────────────────────┐
│                    NTT Verificada de AMO-Lean                    │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   Especificación          Implementación         Binding        │
│   (Lean puro)        →    Optimizada (C)    →    (Rust FFI)     │
│                           con prueba de                         │
│   DFT_n = Σ x_k·ω^{jk}    equivalencia                          │
│                                                                 │
│   Teoremas:               Código:               Uso:            │
│   • ntt_inverse           • ntt_forward_avx2   • Plonky3        │
│   • ntt_convolution       • ntt_inverse_avx2   • zkVM           │
│   • cooley_tukey          • ntt_radix4         • cualquiera     │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘</code></pre>
<h3 id="qué-hace-única-a-esta-ntt">4.3 Qué Hace Única a Esta NTT</h3>
<table>
<colgroup>
<col style="width: 20%" />
<col style="width: 39%" />
<col style="width: 39%" />
</colgroup>
<thead>
<tr>
<th>Aspecto</th>
<th>NTT Tradicional</th>
<th>NTT de AMO-Lean</th>
</tr>
</thead>
<tbody>
<tr>
<td>Corrección</td>
<td>Tests empíricos</td>
<td><strong>Teorema probado</strong></td>
</tr>
<tr>
<td>Optimizaciones</td>
<td>“Creemos que está bien”</td>
<td><strong>Derivadas de propiedades</strong></td>
</tr>
<tr>
<td>Confianza</td>
<td>“Funciona en tests”</td>
<td><strong>Matemáticamente imposible estar mal</strong></td>
</tr>
</tbody>
</table>
<h3 id="teoremas-requeridos">4.4 Teoremas Requeridos</h3>
<pre class="lean"><code>-- 1. Definición formal
def ntt (v : Vec F n) : Vec F n :=
  fun j =&gt; Σ k in range n, v[k] * ω^(j*k)

-- 2. Corrección de la inversa
theorem ntt_inverse_correct (v : Vec F n) :
    intt (ntt v) = v

-- 3. Propiedad de convolución (crítica para multiplicación de polinomios)
theorem ntt_convolution (a b : Vec F n) :
    intt (ntt a * ntt b) = cyclic_conv a b

-- 4. Linealidad
theorem ntt_linear (a b : Vec F n) (c : F) :
    ntt (a + c • b) = ntt a + c • ntt b

-- 5. Factorización Cooley-Tukey (la optimización principal)
theorem cooley_tukey_correct (v : Vec F (m * n)) :
    ntt v = (I_m ⊗ DFT_n) · T · (DFT_m ⊗ I_n) · L · v</code></pre>
<h3 id="entregables-del-modo-c">4.5 Entregables del Modo C</h3>
<table>
<thead>
<tr>
<th>Entregable</th>
<th>Descripción</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ntt_forward</code></td>
<td>NTT forward verificada (escalar + AVX2)</td>
</tr>
<tr>
<td><code>ntt_inverse</code></td>
<td>NTT inversa verificada</td>
</tr>
<tr>
<td><code>ntt_coset</code></td>
<td>NTT sobre cosets (para FRI)</td>
</tr>
<tr>
<td>Crate Rust <code>amolean-ntt</code></td>
<td>Bindings para integración</td>
</tr>
<tr>
<td>Benchmarks</td>
<td>Comparación vs Plonky3</td>
</tr>
<tr>
<td>Paper/Docs</td>
<td>Publicación académica</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="estado-actual-del-proyecto">5. Estado Actual del Proyecto</h2>
<h3 id="fases-completadas">5.1 Fases Completadas</h3>
<table>
<thead>
<tr>
<th>Fase</th>
<th>Descripción</th>
<th>Resultado</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>0</strong></td>
<td>Proof of Concept</td>
<td>32.3x speedup Lean→C</td>
</tr>
<tr>
<td><strong>1</strong></td>
<td>Goldilocks Field</td>
<td>568 M elem/s throughput</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td>E-Graph Optimization</td>
<td>91.67% reducción de ops</td>
</tr>
<tr>
<td><strong>2.5</strong></td>
<td>Verificación Formal</td>
<td>0 sorry en reglas core</td>
</tr>
<tr>
<td><strong>3</strong></td>
<td>AVX2 SIMD</td>
<td>4.00x speedup (100% eficiencia)</td>
</tr>
</tbody>
</table>
<h3 id="inventario-de-componentes">5.2 Inventario de Componentes</h3>
<table>
<thead>
<tr>
<th>Componente</th>
<th>Estado</th>
<th>Reutilizable B</th>
<th>Reutilizable C</th>
</tr>
</thead>
<tbody>
<tr>
<td>E-Graph Engine</td>
<td>✅ 100%</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>Verified Rewrite Rules (12)</td>
<td>✅ 100%</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>Expr/VecExpr/MatExpr AST</td>
<td>✅ 100%</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>Goldilocks Spec Lean</td>
<td>✅ 100%</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>Goldilocks C (escalar)</td>
<td>✅ 100%</td>
<td>Ref</td>
<td>✅</td>
</tr>
<tr>
<td>Goldilocks C (AVX2)</td>
<td>✅ 100%</td>
<td>Ref</td>
<td>✅</td>
</tr>
<tr>
<td>FRI Fold Spec</td>
<td>✅ 100%</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>FRI Fold C</td>
<td>✅ 100%</td>
<td>Ref</td>
<td>✅</td>
</tr>
<tr>
<td>Poseidon2 Spec</td>
<td>⚠️ 60%</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>NTT Spec formal</td>
<td>⚠️ 20%</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>NTT Teoremas</td>
<td>❌ 0%</td>
<td>Necesario</td>
<td>Necesario</td>
</tr>
<tr>
<td>NTT CodeGen</td>
<td>❌ 0%</td>
<td>N/A</td>
<td>Necesario</td>
</tr>
</tbody>
</table>
<h3 id="porcentajes-de-completitud">5.3 Porcentajes de Completitud</h3>
<pre><code>Estado Actual (Enero 2026)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Core Común          ████████████░░░░░░░░  55-60%
Modo B (Verificador)█████░░░░░░░░░░░░░░░  25-30%
Modo C (Generador)  ███░░░░░░░░░░░░░░░░░  15-20%</code></pre>
<hr />
<h2 id="roadmap-de-desarrollo">6. Roadmap de Desarrollo</h2>
<h3 id="diagrama-de-fases">6.1 Diagrama de Fases</h3>
<pre><code>┌─────────────┐    ┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│   FASE 4    │    │   FASE 5    │    │  FASE 6A    │    │  FASE 6B    │
│ Empaquetar  │ ─▶ │  Core NTT   │ ─▶ │ Verificador │ ─▶ │  Generador  │
│  [2-3 sem]  │    │  [4-6 sem]  │    │  [3-4 sem]  │    │  [4-6 sem]  │
└─────────────┘    └─────────────┘    └─────────────┘    └─────────────┘
      │                  │                  │                  │
      ▼                  ▼                  ▼                  ▼
   v0.1.0            HITO 1             HITO 2             HITO 3
   Tag inicial       Core listo        Modo B listo       Modo C listo</code></pre>
<h3 id="fase-4-empaquetar-actual">6.2 Fase 4: Empaquetar (ACTUAL)</h3>
<p><strong>Duración:</strong> 2-3 semanas <strong>Objetivo:</strong>
Cerrar deuda técnica, no agregar features</p>
<table>
<thead>
<tr>
<th>Tarea</th>
<th>Descripción</th>
<th>Prioridad</th>
</tr>
</thead>
<tbody>
<tr>
<td>Eliminar 3 sorry</td>
<td><code>pow_one</code>, <code>one_pow</code>,
<code>zero_pow</code></td>
<td>Alta</td>
</tr>
<tr>
<td>Crear <code>libamolean</code> básica</td>
<td>Headers públicos vs privados</td>
<td>Alta</td>
</tr>
<tr>
<td>CMakeLists.txt</td>
<td>Build system con detección CPU</td>
<td>Alta</td>
</tr>
<tr>
<td>README + ejemplos</td>
<td>Documentación mínima de uso</td>
<td>Alta</td>
</tr>
<tr>
<td>Tag v0.1.0</td>
<td>Release inicial en GitHub</td>
<td>Alta</td>
</tr>
</tbody>
</table>
<p><strong>Entregable:</strong> <code>libamolean</code> v0.1.0 con FRI
Fold usable</p>
<h3 id="fase-5-core-ntt-hito-1">6.3 Fase 5: Core NTT (HITO 1)</h3>
<p><strong>Duración:</strong> 4-6 semanas <strong>Prerequisito:</strong>
Fase 4 completada <strong>Objetivo:</strong> Especificación formal
completa de NTT</p>
<table>
<thead>
<tr>
<th>Semana</th>
<th>Tarea</th>
</tr>
</thead>
<tbody>
<tr>
<td>1-2</td>
<td><code>NTT/Definition.lean</code> - DFT como suma formal</td>
</tr>
<tr>
<td>2-3</td>
<td><code>NTT/Properties.lean</code> - Inversa, linealidad</td>
</tr>
<tr>
<td>3-4</td>
<td><code>NTT/CooleyTukey.lean</code> - Factorización</td>
</tr>
<tr>
<td>4-5</td>
<td><code>NTT/Butterfly.lean</code> - Operación atómica</td>
</tr>
<tr>
<td>5-6</td>
<td>Tests, documentación, refinamiento</td>
</tr>
</tbody>
</table>
<p><strong>Desbloquea:</strong> Ambos modos B y C se vuelven
posibles</p>
<h3 id="fase-6a-verificador-hito-2">6.4 Fase 6A: Verificador (HITO
2)</h3>
<p><strong>Duración:</strong> 3-4 semanas <strong>Prerequisito:</strong>
Hito 1 (Core NTT) <strong>Objetivo:</strong> AMO-Lean funciona como
verificador</p>
<table>
<thead>
<tr>
<th>Semana</th>
<th>Tarea</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Framework de mapping reglas → teoremas</td>
</tr>
<tr>
<td>2</td>
<td>Mapear Goldilocks ops de Plonky3</td>
</tr>
<tr>
<td>3</td>
<td>Generar certificado para Goldilocks</td>
</tr>
<tr>
<td>4</td>
<td>CI para re-verificar en releases Plonky3</td>
</tr>
</tbody>
</table>
<p><strong>Entregable:</strong> “Plonky3 Goldilocks verified by
AMO-Lean”</p>
<h3 id="fase-6b-ntt-ejecutable-hito-3">6.5 Fase 6B: NTT Ejecutable (HITO
3)</h3>
<p><strong>Duración:</strong> 4-6 semanas <strong>Prerequisito:</strong>
Hito 1 (Core NTT) <strong>Objetivo:</strong> NTT verificada usable desde
Rust</p>
<table>
<thead>
<tr>
<th>Semana</th>
<th>Tarea</th>
</tr>
</thead>
<tbody>
<tr>
<td>1-2</td>
<td>NTT CodeGen C escalar</td>
</tr>
<tr>
<td>2-3</td>
<td>NTT CodeGen C AVX2</td>
</tr>
<tr>
<td>3-4</td>
<td>Tests de equivalencia spec = impl</td>
</tr>
<tr>
<td>4-5</td>
<td>Benchmarks vs Plonky3 NTT</td>
</tr>
<tr>
<td>5-6</td>
<td>Rust bindings (<code>amolean-ntt</code> crate)</td>
</tr>
</tbody>
</table>
<p><strong>Entregable:</strong> <code>amolean-ntt</code> crate
publicable</p>
<hr />
<h2 id="estructura-de-archivos-objetivo">7. Estructura de Archivos
Objetivo</h2>
<pre><code>amo-lean/
├── AmoLean/
│   ├── Core/
│   │   ├── Expr.lean              # [✅] AST de expresiones
│   │   ├── Rewrite.lean           # [✅] Reglas de reescritura
│   │   └── Correctness.lean       # [✅] Teoremas de soundness
│   │
│   ├── EGraph/
│   │   ├── Basic.lean             # [✅] E-Graph engine
│   │   ├── Saturate.lean          # [✅] Equality saturation
│   │   └── VerifiedRules.lean     # [✅] Reglas con pruebas
│   │
│   ├── Specs/
│   │   ├── Field/
│   │   │   └── Goldilocks.lean    # [✅] Campo Goldilocks
│   │   ├── NTT/
│   │   │   ├── Definition.lean    # [⏳] DFT formal
│   │   │   ├── Properties.lean    # [⏳] Teoremas
│   │   │   └── CooleyTukey.lean   # [⏳] Factorización
│   │   ├── FRI/
│   │   │   └── Fold.lean          # [✅] FRI Fold
│   │   └── Poseidon/
│   │       └── Spec.lean          # [⚠️] Poseidon2
│   │
│   ├── Verifier/                  # MODO B
│   │   ├── RuleMapping.lean       # [⏳] Framework
│   │   ├── Plonky3/
│   │   │   ├── Goldilocks.lean    # [⏳] Reglas Plonky3
│   │   │   └── NTT.lean           # [⏳] NTT Plonky3
│   │   └── Certificate.lean       # [⏳] Generación
│   │
│   └── CodeGen/                   # MODO C
│       ├── Core.lean              # [✅] IR común
│       ├── C/
│       │   ├── Scalar.lean        # [✅] Backend escalar
│       │   └── AVX2.lean          # [✅] Backend SIMD
│       └── Rust/
│           └── Basic.lean         # [⏳] Backend Rust
│
├── libamolean/                    # Librería C
│   ├── include/
│   │   └── amolean.h              # API pública
│   ├── src/
│   │   ├── field_goldilocks.c
│   │   ├── fri_fold.c
│   │   └── ntt.c                  # [⏳]
│   └── CMakeLists.txt
│
├── amolean-ntt/                   # Crate Rust [⏳]
│   ├── Cargo.toml
│   └── src/
│       └── lib.rs
│
└── docs/
    └── project/
        ├── UNIFIED_PLAN.md        # Este documento
        ├── ROADMAP.md
        └── PROGRESS.md</code></pre>
<hr />
<h2 id="métricas-de-éxito">8. Métricas de Éxito</h2>
<h3 id="por-fase">8.1 Por Fase</h3>
<table>
<thead>
<tr>
<th>Fase</th>
<th>Métrica de Éxito</th>
</tr>
</thead>
<tbody>
<tr>
<td>4</td>
<td>v0.1.0 taggeada, CI verde, 0 sorry</td>
</tr>
<tr>
<td>5</td>
<td>5+ teoremas NTT probados</td>
</tr>
<tr>
<td>6A</td>
<td>Certificado para Goldilocks de Plonky3</td>
</tr>
<tr>
<td>6B</td>
<td>Benchmark NTT ≥80% rendimiento de Plonky3</td>
</tr>
</tbody>
</table>
<h3 id="globales">8.2 Globales</h3>
<table>
<thead>
<tr>
<th>Métrica</th>
<th>Objetivo</th>
</tr>
</thead>
<tbody>
<tr>
<td>Tests totales</td>
<td>&gt;1500 passing</td>
</tr>
<tr>
<td>Sorry en teoremas</td>
<td>0</td>
</tr>
<tr>
<td>Cobertura de specs</td>
<td>Goldilocks + NTT + FRI</td>
</tr>
<tr>
<td>Documentación</td>
<td>README + ejemplos + API docs</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="riesgos-y-mitigaciones">9. Riesgos y Mitigaciones</h2>
<table>
<colgroup>
<col style="width: 18%" />
<col style="width: 32%" />
<col style="width: 20%" />
<col style="width: 27%" />
</colgroup>
<thead>
<tr>
<th>Riesgo</th>
<th>Probabilidad</th>
<th>Impacto</th>
<th>Mitigación</th>
</tr>
</thead>
<tbody>
<tr>
<td>Teoremas NTT difíciles</td>
<td>Media</td>
<td>Alto</td>
<td>Consultar literatura, usar Mathlib</td>
</tr>
<tr>
<td>Plonky3 cambia API</td>
<td>Media</td>
<td>Medio</td>
<td>CI detecta, re-mapear</td>
</tr>
<tr>
<td>Performance inferior</td>
<td>Baja</td>
<td>Alto</td>
<td>Benchmarks continuos</td>
</tr>
<tr>
<td>Scope creep</td>
<td>Alta</td>
<td>Alto</td>
<td><strong>Seguir este documento</strong></td>
</tr>
</tbody>
</table>
<hr />
<h2 id="decisiones-de-diseño-clave">10. Decisiones de Diseño Clave</h2>
<h3 id="dd-007-arquitectura-dual-bc">DD-007: Arquitectura Dual B+C</h3>
<p><strong>Decisión:</strong> AMO-Lean soporta dos modos (Verificador y
Generador) con core compartido.</p>
<p><strong>Razón:</strong> Maximiza reutilización (~60% compartido) y
flexibilidad.</p>
<h3 id="dd-008-ntt-como-componente-principal-de-modo-c">DD-008: NTT como
Componente Principal de Modo C</h3>
<p><strong>Decisión:</strong> El primer componente verificado será NTT,
no Poseidon ni Merkle.</p>
<p><strong>Razón:</strong> NTT es matemáticamente rico (muchas
propiedades formalizables) y crítico para rendimiento en STARKs.</p>
<h3 id="dd-009-certificados-para-plonky3-primero">DD-009: Certificados
para Plonky3 Primero</h3>
<p><strong>Decisión:</strong> El primer target del Verificador será
Plonky3, no arkworks ni otros.</p>
<p><strong>Razón:</strong> Plonky3 usa Goldilocks (que ya tenemos) y
tiene adopción creciente.</p>
<h3 id="dd-010-no-agregar-campos-nuevos-en-fase-4-5">DD-010: No Agregar
Campos Nuevos en Fase 4-5</h3>
<p><strong>Decisión:</strong> M31 y BabyBear se posponen hasta después
de Hito 3.</p>
<p><strong>Razón:</strong> Evitar scope creep. Primero completar
funcionalidad core.</p>
<hr />
<h2 id="glosario">11. Glosario</h2>
<table>
<colgroup>
<col style="width: 42%" />
<col style="width: 57%" />
</colgroup>
<thead>
<tr>
<th>Término</th>
<th>Definición</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>E-Graph</strong></td>
<td>Estructura que representa múltiples expresiones equivalentes</td>
</tr>
<tr>
<td><strong>Equality Saturation</strong></td>
<td>Aplicar todas las reglas hasta saturar</td>
</tr>
<tr>
<td><strong>NTT</strong></td>
<td>Number Theoretic Transform (FFT sobre campos finitos)</td>
</tr>
<tr>
<td><strong>Cooley-Tukey</strong></td>
<td>Algoritmo de factorización para FFT/NTT</td>
</tr>
<tr>
<td><strong>Goldilocks</strong></td>
<td>Campo finito p = 2^64 - 2^32 + 1</td>
</tr>
<tr>
<td><strong>Plonky3</strong></td>
<td>Librería Rust para STARKs (Polygon)</td>
</tr>
<tr>
<td><strong>Verificador (Modo B)</strong></td>
<td>Certifica que código externo es correcto</td>
</tr>
<tr>
<td><strong>Generador (Modo C)</strong></td>
<td>Produce código optimizado con pruebas</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="referencias">12. Referencias</h2>
<ul>
<li>SPIRAL Project: https://spiral.ece.cmu.edu/</li>
<li>Plonky3: https://github.com/Plonky3/Plonky3</li>
<li>Mathlib: https://leanprover-community.github.io/mathlib4_docs/</li>
<li>“Term Rewriting and All That” (Baader &amp; Nipkow)</li>
<li>“Equality Saturation: A New Approach to Optimization” (Tate et
al.)</li>
</ul>
<hr />
<h2 id="historial-de-cambios">13. Historial de Cambios</h2>
<table>
<thead>
<tr>
<th>Fecha</th>
<th>Versión</th>
<th>Cambio</th>
</tr>
</thead>
<tbody>
<tr>
<td>2026-01-29</td>
<td>1.0</td>
<td>Documento inicial con plan unificado</td>
</tr>
</tbody>
</table>
<hr />
<p><strong>Aprobado por:</strong> Manuel Puebla <strong>Fecha de
aprobación:</strong> 2026-01-29</p>
<hr />
<p><em>AMO-Lean: Automatic Mathematical Optimizer in Lean</em></p>
</body>
</html>
