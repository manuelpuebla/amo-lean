/**
 * fri_fold.h - FRI Fold Operations for AMO-Lean
 *
 * Generated by AmoLean.Vector.CodeGen
 *
 * This file provides FRI fold operations that:
 * - Use field_add/field_mul for field arithmetic (DD-002)
 * - Use restrict for non-aliasing optimization (DD-003)
 * - Include debug assertions when DEBUG is defined (DD-006)
 *
 * Usage:
 *   #define FIELD_GOLDILOCKS  // or FIELD_NATIVE for testing
 *   #define DEBUG             // optional: enable assertions
 *   #include "field_ops.h"
 *   #include "fri_fold.h"
 */

#ifndef FRI_FOLD_H
#define FRI_FOLD_H

#include <stddef.h>
#include <assert.h>

/* Assumes field_ops.h is included before this header */
#ifndef FIELD_NAME
#error "Include field_ops.h before fri_fold.h"
#endif

/**
 * Parametric FRI fold operation: out[i] = even[i] + alpha * odd[i]
 *
 * PROOF_ANCHOR: fri_fold_parametric
 * Preconditions:
 *   - n > 0
 *   - even, odd, out are non-null
 *   - even, odd, out point to arrays of at least n elements
 *   - out does not alias even or odd (required for restrict)
 * Postconditions:
 *   - forall i in [0, n): out[i] == even[i] + alpha * odd[i]
 *   - output array is fully initialized
 * Invariants:
 *   - All arithmetic uses field_add/field_mul (per DD-002)
 */
void fri_fold(
    size_t n,
    const field_t* restrict even,
    const field_t* restrict odd,
    field_t* restrict out,
    field_t alpha
) {
#ifdef DEBUG
    assert(n > 0 && "n must be positive");
    assert(even != NULL && "even is null");
    assert(odd != NULL && "odd is null");
    assert(out != NULL && "out is null");
    assert(out != even && "out aliases even");
    assert(out != odd && "out aliases odd");
#endif
    for (size_t i = 0; i < n; i++) {
        out[i] = field_add(even[i], field_mul(alpha, odd[i]));
    }
}


/**
 * FRI layer fold: Fold input[2n] to output[n]
 *
 * PROOF_ANCHOR: fri_fold_layer
 * Preconditions:
 *   - n > 0
 *   - input has 2*n elements
 *   - output has n elements
 *   - output does not alias input
 * Postconditions:
 *   - forall i in [0, n): output[i] == input[2*i] + alpha * input[2*i + 1]
 * Invariants:
 *   - Memory accesses are sequential (cache-friendly)
 *   - All arithmetic uses field_add/field_mul (per DD-002)
 */
void fri_fold_layer(
    size_t n,
    const field_t* restrict input,
    field_t* restrict output,
    field_t alpha
) {
#ifdef DEBUG
    assert(n > 0 && "n must be positive");
    assert(input != NULL && "input is null");
    assert(output != NULL && "output is null");
    assert(output != input && "output aliases input");
#endif
    for (size_t i = 0; i < n; i++) {
        field_t even = input[2 * i];
        field_t odd = input[2 * i + 1];
        output[i] = field_add(even, field_mul(alpha, odd));
    }
}


/* Size-specific versions for common sizes */
/**
 * FRI fold operation: out[i] = even[i] + alpha * odd[i]
 *
 * PROOF_ANCHOR: fri_fold
 * Preconditions:
 *   - even, odd, out are non-null
 *   - even, odd, out point to arrays of at least n elements
 *   - out does not alias even or odd (required for restrict)
 * Postconditions:
 *   - forall i in [0, n): out[i] == even[i] + alpha * odd[i]
 *   - output array is fully initialized
 * Invariants:
 *   - All arithmetic uses field_add/field_mul (per DD-002)
 */
void fri_fold_16(
    const field_t* restrict even,
    const field_t* restrict odd,
    field_t* restrict out,
    field_t alpha
) {
#ifdef DEBUG
    assert(even != NULL && "even is null");
    assert(odd != NULL && "odd is null");
    assert(out != NULL && "out is null");
    assert(out != even && "out aliases even");
    assert(out != odd && "out aliases odd");
#endif
    for (size_t i = 0; i < 16; i++) {
        out[i] = field_add(even[i], field_mul(alpha, odd[i]));
    }
}

/**
 * FRI fold operation: out[i] = even[i] + alpha * odd[i]
 *
 * PROOF_ANCHOR: fri_fold
 * Preconditions:
 *   - even, odd, out are non-null
 *   - even, odd, out point to arrays of at least n elements
 *   - out does not alias even or odd (required for restrict)
 * Postconditions:
 *   - forall i in [0, n): out[i] == even[i] + alpha * odd[i]
 *   - output array is fully initialized
 * Invariants:
 *   - All arithmetic uses field_add/field_mul (per DD-002)
 */
void fri_fold_64(
    const field_t* restrict even,
    const field_t* restrict odd,
    field_t* restrict out,
    field_t alpha
) {
#ifdef DEBUG
    assert(even != NULL && "even is null");
    assert(odd != NULL && "odd is null");
    assert(out != NULL && "out is null");
    assert(out != even && "out aliases even");
    assert(out != odd && "out aliases odd");
#endif
    for (size_t i = 0; i < 64; i++) {
        out[i] = field_add(even[i], field_mul(alpha, odd[i]));
    }
}

/**
 * FRI fold operation: out[i] = even[i] + alpha * odd[i]
 *
 * PROOF_ANCHOR: fri_fold
 * Preconditions:
 *   - even, odd, out are non-null
 *   - even, odd, out point to arrays of at least n elements
 *   - out does not alias even or odd (required for restrict)
 * Postconditions:
 *   - forall i in [0, n): out[i] == even[i] + alpha * odd[i]
 *   - output array is fully initialized
 * Invariants:
 *   - All arithmetic uses field_add/field_mul (per DD-002)
 */
void fri_fold_256(
    const field_t* restrict even,
    const field_t* restrict odd,
    field_t* restrict out,
    field_t alpha
) {
#ifdef DEBUG
    assert(even != NULL && "even is null");
    assert(odd != NULL && "odd is null");
    assert(out != NULL && "out is null");
    assert(out != even && "out aliases even");
    assert(out != odd && "out aliases odd");
#endif
    for (size_t i = 0; i < 256; i++) {
        out[i] = field_add(even[i], field_mul(alpha, odd[i]));
    }
}

/**
 * FRI fold operation: out[i] = even[i] + alpha * odd[i]
 *
 * PROOF_ANCHOR: fri_fold
 * Preconditions:
 *   - even, odd, out are non-null
 *   - even, odd, out point to arrays of at least n elements
 *   - out does not alias even or odd (required for restrict)
 * Postconditions:
 *   - forall i in [0, n): out[i] == even[i] + alpha * odd[i]
 *   - output array is fully initialized
 * Invariants:
 *   - All arithmetic uses field_add/field_mul (per DD-002)
 */
void fri_fold_1024(
    const field_t* restrict even,
    const field_t* restrict odd,
    field_t* restrict out,
    field_t alpha
) {
#ifdef DEBUG
    assert(even != NULL && "even is null");
    assert(odd != NULL && "odd is null");
    assert(out != NULL && "out is null");
    assert(out != even && "out aliases even");
    assert(out != odd && "out aliases odd");
#endif
    for (size_t i = 0; i < 1024; i++) {
        out[i] = field_add(even[i], field_mul(alpha, odd[i]));
    }
}


#endif /* FRI_FOLD_H */
