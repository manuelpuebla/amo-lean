# libamolean

Header-only C library for **formally verified mathematical operations**, generated by AMO-Lean.

## What is AMO-Lean?

AMO-Lean is an **Automatic Mathematical Optimizer** written in Lean 4. It:

1. Takes mathematical specifications (MatExpr, VecExpr)
2. Applies formally verified rewrite rules via E-Graph
3. Generates optimized C code

All optimizations are **proven correct** using Lean's theorem prover. This library contains the generated C code.

## Features

- **Goldilocks field arithmetic** (p = 2^64 - 2^32 + 1)
- **AVX2 SIMD optimizations** (4-way parallel operations)
- **FRI fold operations** (for zero-knowledge proofs)
- **Formally verified** - all optimizations proven correct in Lean

## Quick Start

### Include in your project

```c
#include <amolean/amolean.h>

int main() {
    // Goldilocks field arithmetic
    uint64_t a = 12345;
    uint64_t b = 67890;

    uint64_t sum = goldilocks_add(a, b);
    uint64_t prod = goldilocks_mul(a, b);
    uint64_t power = goldilocks_pow(a, 7);  // a^7 (S-box)

    printf("sum = %llu\n", (unsigned long long)sum);
    printf("prod = %llu\n", (unsigned long long)prod);
    printf("a^7 = %llu\n", (unsigned long long)power);

    return 0;
}
```

### AVX2 SIMD (x86-64 only)

```c
#include <amolean/amolean.h>

#ifdef AMOLEAN_HAS_AVX2
void process_batch(const uint64_t* a, const uint64_t* b, uint64_t* result, size_t n) {
    // Process 4 elements at a time
    for (size_t i = 0; i + 4 <= n; i += 4) {
        __m256i va = _mm256_loadu_si256((const __m256i*)&a[i]);
        __m256i vb = _mm256_loadu_si256((const __m256i*)&b[i]);
        __m256i vr = goldilocks_avx2_mul(va, vb);
        _mm256_storeu_si256((__m256i*)&result[i], vr);
    }

    // Handle remaining elements with scalar
    for (size_t i = (n / 4) * 4; i < n; i++) {
        result[i] = goldilocks_mul(a[i], b[i]);
    }
}
#endif
```

### FRI Fold Operation

```c
#include <amolean/amolean.h>

// FRI fold: combines polynomial evaluations
// result[i] = f_even[i] + alpha * f_odd[i]
void fri_fold_layer(
    const uint64_t* f_even,
    const uint64_t* f_odd,
    uint64_t alpha,
    uint64_t* result,
    size_t n
) {
    for (size_t i = 0; i < n; i++) {
        uint64_t term = goldilocks_mul(alpha, f_odd[i]);
        result[i] = goldilocks_add(f_even[i], term);
    }
}
```

## Building

### With CMake

```bash
mkdir build && cd build
cmake ..
make
ctest  # Run tests
```

### Manual compilation

```bash
# Scalar version (any platform)
gcc -O2 -I include -o my_program my_program.c

# AVX2 version (x86-64)
gcc -O2 -mavx2 -I include -DAMOLEAN_HAS_AVX2=1 -o my_program my_program.c
```

## API Reference

### Goldilocks Field (scalar)

```c
// Constants
#define GOLDILOCKS_P       0xFFFFFFFF00000001ULL  // Prime modulus
#define GOLDILOCKS_EPSILON 0xFFFFFFFFULL          // 2^32 - 1

// Arithmetic
uint64_t goldilocks_add(uint64_t a, uint64_t b);  // a + b mod p
uint64_t goldilocks_sub(uint64_t a, uint64_t b);  // a - b mod p
uint64_t goldilocks_mul(uint64_t a, uint64_t b);  // a * b mod p
uint64_t goldilocks_pow(uint64_t base, uint64_t exp);  // base^exp mod p
```

### Goldilocks Field (AVX2)

```c
// 4-way parallel operations
__m256i goldilocks_avx2_add(__m256i a, __m256i b);
__m256i goldilocks_avx2_sub(__m256i a, __m256i b);
__m256i goldilocks_avx2_mul(__m256i a, __m256i b);
```

## Performance

| Operation | Scalar | AVX2 | Speedup |
|-----------|--------|------|---------|
| Addition  | ~1 ns  | ~1 ns (4 elements) | 4x |
| Subtraction | ~1 ns | ~1 ns (4 elements) | 4x |
| Multiplication | ~5 ns | ~5 ns (4 elements) | **4x** |

AVX2 achieves **100% theoretical efficiency** (4x speedup for 4-way SIMD).

## Formal Verification

All optimization rules are proven correct in Lean 4:

| Rule | Status |
|------|--------|
| x + 0 = x | ✅ Verified |
| x * 1 = x | ✅ Verified |
| x * 0 = 0 | ✅ Verified |
| x^0 = 1 | ✅ Verified |
| x^1 = x | ✅ Verified |
| 1^n = 1 | ✅ Verified |
| 0^(n+1) = 0 | ✅ Verified |
| a*(b+c) = a*b + a*c | ✅ Verified |
| ... | 19 rules total |

See [VerifiedRules.lean](../AmoLean/EGraph/VerifiedRules.lean) for the complete list.

## License

MIT License

## Links

- [AMO-Lean Project](https://github.com/amo-lean/amo-lean)
- [Documentation](../docs/)
