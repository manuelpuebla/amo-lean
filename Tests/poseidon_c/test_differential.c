/**
 * Poseidon2 Differential Fuzzing Test
 *
 * Test 2.3: End-to-End Differential Fuzzing (Golden Standard)
 *
 * This test compares C implementation against Lean specification.
 * Test vectors are generated by Lean and verified by C.
 */

#include "bn254_field.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* ============================================================================
 * Test Vector Format
 *
 * Each test vector is a line with format:
 * INPUT: <x_limb0> <x_limb1> <x_limb2> <x_limb3> OUTPUT: <y_limb0> ... <y_limb3>
 * ============================================================================ */

typedef struct {
    uint64_t input[4];
    uint64_t expected_output[4];
} test_vector;

static int parse_test_vector(const char *line, test_vector *tv) {
    return sscanf(line,
        "INPUT: %llx %llx %llx %llx OUTPUT: %llx %llx %llx %llx",
        (unsigned long long *)&tv->input[0],
        (unsigned long long *)&tv->input[1],
        (unsigned long long *)&tv->input[2],
        (unsigned long long *)&tv->input[3],
        (unsigned long long *)&tv->expected_output[0],
        (unsigned long long *)&tv->expected_output[1],
        (unsigned long long *)&tv->expected_output[2],
        (unsigned long long *)&tv->expected_output[3]
    ) == 8;
}

/* ============================================================================
 * Known Test Vectors (hardcoded for basic validation)
 *
 * These are computed using the Lean specification.
 * Format: input (normal form), expected output (normal form)
 * ============================================================================ */

static const test_vector known_vectors[] = {
    /* 0^5 = 0 */
    {{0, 0, 0, 0}, {0, 0, 0, 0}},

    /* 1^5 = 1 */
    {{1, 0, 0, 0}, {1, 0, 0, 0}},

    /* 2^5 = 32 */
    {{2, 0, 0, 0}, {32, 0, 0, 0}},

    /* 3^5 = 243 */
    {{3, 0, 0, 0}, {243, 0, 0, 0}},

    /* 5^5 = 3125 */
    {{5, 0, 0, 0}, {3125, 0, 0, 0}},

    /* 7^5 = 16807 */
    {{7, 0, 0, 0}, {16807, 0, 0, 0}},

    /* 10^5 = 100000 */
    {{10, 0, 0, 0}, {100000, 0, 0, 0}},

    /* 256^5 = 2^40 = 1099511627776 */
    {{256, 0, 0, 0}, {1099511627776ULL, 0, 0, 0}},
};

static const int num_known_vectors = sizeof(known_vectors) / sizeof(known_vectors[0]);

/* ============================================================================
 * Test Functions
 * ============================================================================ */

static int tests_passed = 0;
static int tests_failed = 0;

static int test_known_vectors(const field_params *p) {
    printf("  Test: Known test vectors (%d vectors)\n", num_known_vectors);

    for (int i = 0; i < num_known_vectors; i++) {
        const test_vector *tv = &known_vectors[i];

        /* Input in normal form -> Montgomery */
        bn254_fe x, result, expected;
        bn254_from_limbs(&x, tv->input);
        bn254_to_mont(&x, &x, p);

        /* Expected output in normal form -> Montgomery */
        bn254_from_limbs(&expected, tv->expected_output);
        bn254_to_mont(&expected, &expected, p);

        /* Compute x^5 */
        bn254_sbox5(&result, &x, p);

        /* Compare */
        if (!bn254_eq(&result, &expected)) {
            printf("    FAIL at vector %d\n", i);
            printf("    Input: %llx %llx %llx %llx\n",
                (unsigned long long)tv->input[0],
                (unsigned long long)tv->input[1],
                (unsigned long long)tv->input[2],
                (unsigned long long)tv->input[3]);

            bn254_fe result_normal, expected_normal;
            bn254_from_mont(&result_normal, &result, p);
            bn254_from_mont(&expected_normal, &expected, p);

            printf("    Expected (normal): %llx %llx %llx %llx\n",
                (unsigned long long)expected_normal.limbs[0],
                (unsigned long long)expected_normal.limbs[1],
                (unsigned long long)expected_normal.limbs[2],
                (unsigned long long)expected_normal.limbs[3]);
            printf("    Got (normal):      %llx %llx %llx %llx\n",
                (unsigned long long)result_normal.limbs[0],
                (unsigned long long)result_normal.limbs[1],
                (unsigned long long)result_normal.limbs[2],
                (unsigned long long)result_normal.limbs[3]);

            tests_failed++;
            return 0;
        }
    }

    printf("    PASS (%d vectors)\n", num_known_vectors);
    tests_passed++;
    return 1;
}

static int test_from_file(const field_params *p, const char *filename) {
    printf("  Test: Differential fuzzing from file '%s'\n", filename);

    FILE *f = fopen(filename, "r");
    if (!f) {
        printf("    SKIP: File not found (run 'make gen_vectors' first)\n");
        return 1;  /* Not a failure, just skip */
    }

    char line[512];
    int vectors_tested = 0;
    int vectors_failed = 0;

    while (fgets(line, sizeof(line), f)) {
        if (line[0] == '#' || line[0] == '\n') continue;  /* Skip comments */

        test_vector tv;
        if (!parse_test_vector(line, &tv)) {
            printf("    WARN: Failed to parse line: %s", line);
            continue;
        }

        /* Input in normal form -> Montgomery */
        bn254_fe x, result;
        bn254_from_limbs(&x, tv.input);
        bn254_to_mont(&x, &x, p);

        /* Compute x^5 */
        bn254_sbox5(&result, &x, p);

        /* Convert result back to normal form for comparison */
        bn254_fe result_normal;
        bn254_from_mont(&result_normal, &result, p);

        /* Compare */
        int match = 1;
        for (int i = 0; i < 4; i++) {
            if (result_normal.limbs[i] != tv.expected_output[i]) {
                match = 0;
                break;
            }
        }

        if (!match) {
            vectors_failed++;
            if (vectors_failed <= 5) {  /* Only print first 5 failures */
                printf("    FAIL at vector %d:\n", vectors_tested);
                printf("      Input:    %llx %llx %llx %llx\n",
                    (unsigned long long)tv.input[0],
                    (unsigned long long)tv.input[1],
                    (unsigned long long)tv.input[2],
                    (unsigned long long)tv.input[3]);
                printf("      Expected: %llx %llx %llx %llx\n",
                    (unsigned long long)tv.expected_output[0],
                    (unsigned long long)tv.expected_output[1],
                    (unsigned long long)tv.expected_output[2],
                    (unsigned long long)tv.expected_output[3]);
                printf("      Got:      %llx %llx %llx %llx\n",
                    (unsigned long long)result_normal.limbs[0],
                    (unsigned long long)result_normal.limbs[1],
                    (unsigned long long)result_normal.limbs[2],
                    (unsigned long long)result_normal.limbs[3]);
            }
        }

        vectors_tested++;
    }

    fclose(f);

    if (vectors_failed > 0) {
        printf("    FAIL: %d/%d vectors failed\n", vectors_failed, vectors_tested);
        tests_failed++;
        return 0;
    }

    printf("    PASS (%d vectors)\n", vectors_tested);
    tests_passed++;
    return 1;
}

/* ============================================================================
 * Consistency Test: C vs C (self-check)
 *
 * Verifies that our implementation is internally consistent.
 * ============================================================================ */

static int test_self_consistency(const field_params *p, int num_tests) {
    printf("  Test: Self-consistency (C vs C) - %d random values\n", num_tests);

    bn254_fe x, result1, result2;

    for (int i = 0; i < num_tests; i++) {
        bn254_random(&x, p);

        /* Method 1: sbox5 */
        bn254_sbox5(&result1, &x, p);

        /* Method 2: naive multiplication */
        bn254_fe x2, x3, x4;
        bn254_mul(&x2, &x, &x, p);
        bn254_mul(&x3, &x2, &x, p);
        bn254_mul(&x4, &x3, &x, p);
        bn254_mul(&result2, &x4, &x, p);

        if (!bn254_eq(&result1, &result2)) {
            printf("    FAIL at iteration %d: sbox5 != x*x*x*x*x\n", i);
            tests_failed++;
            return 0;
        }
    }

    printf("    PASS (%d tests)\n", num_tests);
    tests_passed++;
    return 1;
}

/* ============================================================================
 * Main
 * ============================================================================ */

int main(int argc, char *argv[]) {
    printf("═══════════════════════════════════════════════════════════════\n");
    printf("  Poseidon2 Differential Fuzzing Tests\n");
    printf("  Test 2.3: End-to-End Golden Standard Validation\n");
    printf("═══════════════════════════════════════════════════════════════\n\n");

    field_params p;
    bn254_init_params(&p);

    /* Seed PRNG */
    bn254_seed_random(0xDEADBEEF12345678ULL);

    /* Run tests */
    printf("══════ Known Test Vectors ══════\n");
    test_known_vectors(&p);
    printf("\n");

    printf("══════ Self-Consistency Check ══════\n");
    test_self_consistency(&p, 10000);
    printf("\n");

    printf("══════ Differential Fuzzing (Lean vs C) ══════\n");
    const char *vectors_file = (argc > 1) ? argv[1] : "test_vectors.txt";
    test_from_file(&p, vectors_file);
    printf("\n");

    /* Summary */
    printf("═══════════════════════════════════════════════════════════════\n");
    printf("  SUMMARY: %d passed, %d failed\n", tests_passed, tests_failed);
    printf("═══════════════════════════════════════════════════════════════\n");

    return tests_failed > 0 ? 1 : 0;
}
