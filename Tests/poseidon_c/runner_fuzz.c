/**
 * Phase 4b Extended: Rust Oracle -> C Validation Runner
 *
 * Reads test vectors from JSON file generated by Rust (HorizenLabs oracle)
 * and validates against our C implementation.
 *
 * JSON format: { "metadata": {...}, "edge_cases": [...], "random_cases": [...] }
 *
 * Usage: ./runner_fuzz <vectors.json>
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <stdbool.h>
#include <time.h>
#include "bn254_field.h"

/* ============================================================================
 * Round Constants (from HorizenLabs, in standard form - 4 limbs per value)
 * Same constants as in test_fuzz.c and test_vector.c
 * ============================================================================ */

static const uint64_t RC_3[64][3][4] = {
    // Round 0-3 (full rounds)
    {{0x59a09a1a97052816ULL, 0x7f8fcde48bb4c37aULL, 0x8bddd3a93f7804efULL, 0x1d066a255517b7fdULL},
     {0xb7238547d32c1610ULL, 0xb7c6fef31367b68eULL, 0xac3f089cebcc6120ULL, 0x29daefb55f6f2dc6ULL},
     {0x9e8b7ad7b0b4e1d1ULL, 0x2572d76f08ec5c4fULL, 0x1ecbd88ad959d701ULL, 0x1f2cb1624a78ee00ULL}},
    {{0xdb0672ded84f31e5ULL, 0xb11f092a53bbc6e1ULL, 0xbd77c0ed3d14aa27ULL, 0x0aad2e79f15735f2ULL},
     {0x091ccf1595b43f28ULL, 0x37028a98f1dece66ULL, 0xd6f661dd4094375fULL, 0x2252624f8617738cULL},
     {0xd49f4f2c9018d735ULL, 0x91c20626524b2b87ULL, 0x5a65a84a291da1ffULL, 0x1a24913a928b3848ULL}},
    {{0x4fd6dae1508fc47aULL, 0x0a41515ddff497b1ULL, 0x7bfc427b5f11ebb1ULL, 0x22fc468f1759b74dULL},
     {0xefd65515617f6e4dULL, 0xe61956ff0b4121d5ULL, 0x9cd026e9c9ca107aULL, 0x1059ca787f1f89edULL},
     {0xa45cbbfae8b981ceULL, 0x2123011f0bf6f155ULL, 0xf61f3536d877de98ULL, 0x02be9473358461d8ULL}},
    {{0xa1ff3a441a5084a4ULL, 0xaba9b669ac5b8736ULL, 0x2778a749c82ed623ULL, 0x0ec96c8e32962d46ULL},
     {0x48fb2e4d814df57eULL, 0x5a47a7cdb8c99f96ULL, 0x5442d9553c45fa3fULL, 0x292f906e07367740ULL},
     {0x0c63f0b2ffe5657eULL, 0xcc611160a394ea46ULL, 0x26c11b9a0f5e39a5ULL, 0x274982444157b867ULL}},
    // Rounds 4-59: partial (56 rounds)
    {{0x499573f23597d4b5ULL, 0xcedd192f47308731ULL, 0xb63e1855bff015b8ULL, 0x1a1d063e54b1e764ULL}, {0}, {0}},
    {{0xb91b002c5b257c37ULL, 0x08235dccc1aa3793ULL, 0x839d109562590637ULL, 0x26abc66f3fdf8e68ULL}, {0}, {0}},
    {{0x0b3c2b12ff4d7be8ULL, 0x0754427aabca92a7ULL, 0x81a578cfed5aed37ULL, 0x0c7c64a9d8873853ULL}, {0}, {0}},
    {{0xedd383831354b495ULL, 0xba2ebac30dc386b0ULL, 0x9e17f0b6d08b2d1eULL, 0x1cf5998769e9fab7ULL}, {0}, {0}},
    {{0x7aba0b97e66b0109ULL, 0x19828764a9669bc1ULL, 0x564ca60461e9e08bULL, 0x0f5e3a8566be31b7ULL}, {0}, {0}},
    {{0x42bf3d7a531c976eULL, 0xf359a53a180b7d4bULL, 0x95e60e4db0794a01ULL, 0x18df6a9d19ea90d8ULL}, {0}, {0}},
    {{0x4e324055fa3123dcULL, 0xd0ea1d3a3b9d25efULL, 0x6e4b782c3c6e601aULL, 0x04f7bf2c5c0538acULL}, {0}, {0}},
    {{0xe55d54628b89ebe6ULL, 0xe770c0584aa2328cULL, 0x3c40058523748531ULL, 0x29c76ce22255206eULL}, {0}, {0}},
    {{0x00e0e945dbc5ff15ULL, 0x65b1b8e9c6108dbeULL, 0xc053659ab4347f5dULL, 0x198d425a45b78e85ULL}, {0}, {0}},
    {{0x49d3a9a90c3fdf74ULL, 0xa7ff7f6878b3c49dULL, 0x6af3cc79c598a1daULL, 0x25ee27ab6296cd5eULL}, {0}, {0}},
    {{0xc0f88687a96d1381ULL, 0x05845d7d0c55b1b2ULL, 0x24561001c0b6eb15ULL, 0x138ea8e0af41a1e0ULL}, {0}, {0}},
    {{0x4013370a01d95687ULL, 0x42851b5b9811f2caULL, 0xf6e7c2cba2eefd0eULL, 0x306197fb3fab671eULL}, {0}, {0}},
    {{0x86419eaf00e8f620ULL, 0x21db7565e5b42504ULL, 0x2b66f0b4894d4f1aULL, 0x1a0c7d52dc32a443ULL}, {0}, {0}},
    {{0xaa52997da2c54a9fULL, 0xebfbe5f55163cd6cULL, 0x3ff86a8e5c8bdfccULL, 0x2b46b418de80915fULL}, {0}, {0}},
    {{0xfb46e312b5829f64ULL, 0x613a1af5db48e05bULL, 0x01f8b777b9673af9ULL, 0x12d3e0dc00858737ULL}, {0}, {0}},
    {{0xba338a5cb19b3a1fULL, 0xfb2bf768230f648dULL, 0x70f5002ed21d089fULL, 0x263390cf74dc3a88ULL}, {0}, {0}},
    {{0x7d543db52b003dcdULL, 0xf8abb5af40f96f1dULL, 0x0ac884b4ca607ad0ULL, 0x0a14f33a5fe668a6ULL}, {0}, {0}},
    {{0xd847df829bc683b9ULL, 0x27be3a4f01171a1dULL, 0x1a5e86509d68b2daULL, 0x28ead9c586513eabULL}, {0}, {0}},
    {{0xea16cda6e1a7416cULL, 0x888f0ea1abe71cffULL, 0x0972031f1bdb2ac9ULL, 0x1c6ab1c328c3c643ULL}, {0}, {0}},
    {{0x32346015c5b42c94ULL, 0x4f6decd608cb98a9ULL, 0x2b2500239f7f8de0ULL, 0x1fc7e71bc0b81979ULL}, {0}, {0}},
    {{0xe6dd85b93a0ddaa8ULL, 0xc0c1e197c952650eULL, 0xe380e0d860298f17ULL, 0x03e107eb3a42b2ecULL}, {0}, {0}},
    {{0x454505f6941d78cdULL, 0x46452ca57c08697fULL, 0x69c0d52bf88b772cULL, 0x2d354a251f381a46ULL}, {0}, {0}},
    {{0xd14b4606826f794bULL, 0x522551d61606eda3ULL, 0xf687ef14bc566d1cULL, 0x094af88ab05d94baULL}, {0}, {0}},
    {{0xd52b2d249d1396f7ULL, 0xe1ab5b6f2e3195a9ULL, 0x19bcaeabf02f8ca5ULL, 0x19705b783bf3d2dcULL}, {0}, {0}},
    {{0x60cef6852271200eULL, 0x8723b16b7d740a3eULL, 0x1fcc33fee54fc5b2ULL, 0x09bf4acc3a8bce3fULL}, {0}, {0}},
    {{0x543a073f3f3b5e4eULL, 0x3413732f301f7058ULL, 0x50f83c0c8fab6284ULL, 0x1803f8200db6013cULL}, {0}, {0}},
    {{0xd41f7fef2faf3e5cULL, 0xbf6fb02d4454c0adULL, 0x30595b160b8d1f38ULL, 0x0f80afb5046244deULL}, {0}, {0}},
    {{0x7dc3f98219529d78ULL, 0xabcfcf643f4a6feaULL, 0xd77f0088c1cfc964ULL, 0x126ee1f8504f15c3ULL}, {0}, {0}},
    {{0xef86f991d7d0a591ULL, 0x0ffb4ee63175ddf8ULL, 0x69bfb3d919552ca1ULL, 0x23c203d10cfcc60fULL}, {0}, {0}},
    {{0x7c5a339f7744fb94ULL, 0x3dec1ee4eec2cf74ULL, 0xec0d09705fa3a630ULL, 0x2a2ae15d8b143709ULL}, {0}, {0}},
    {{0xb6b5d89081970b2bULL, 0xc3d3b3006cb461bbULL, 0x47e5c381ab6343ecULL, 0x07b60dee586ed6efULL}, {0}, {0}},
    {{0x132cfe583c9311bdULL, 0x8a98a320baa7d152ULL, 0x885d95c494c1ae3dULL, 0x27316b559be3edfdULL}, {0}, {0}},
    {{0x2f5f9af0c0342e76ULL, 0xef834cc2a743ed66ULL, 0xd8937cb2d3f84311ULL, 0x1d5c49ba157c32b8ULL}, {0}, {0}},
    {{0x7c24bd5940968488ULL, 0x09c01bf6979938f6ULL, 0x332774e0b850b5ecULL, 0x2f8b124e78163b2fULL}, {0}, {0}},
    {{0x665f75260113b3d5ULL, 0x1d4cba6554e51d84ULL, 0xdc5b7aa09a9ce21bULL, 0x1e6843a5457416b6ULL}, {0}, {0}},
    {{0x1f5bc79f21641d4bULL, 0xa68daf9ac6a189abULL, 0x5fca25c9929c8ad9ULL, 0x11cdf00a35f650c5ULL}, {0}, {0}},
    {{0xe82b5b9b7eb560bcULL, 0x608b2815c77355b7ULL, 0x2ef36e588158d6d4ULL, 0x21632de3d3bbc5e4ULL}, {0}, {0}},
    {{0x49d7b5c51c18498aULL, 0x255ae48ef2a329e4ULL, 0x97b27025fbd245e0ULL, 0x0de625758452efbdULL}, {0}, {0}},
    {{0x9b09546ba0838098ULL, 0xdd9e1e1c6f0fb6b0ULL, 0xe2febfd4d976cc01ULL, 0x2ad253c053e75213ULL}, {0}, {0}},
    {{0xd35702e38d60b077ULL, 0x3dd49cdd13c813b7ULL, 0x6ec7681ec39b3be9ULL, 0x1d6b169ed63872dcULL}, {0}, {0}},
    {{0xc3a54e706cfef7feULL, 0x0be3ea70a24d5568ULL, 0xb9127c4941b67fedULL, 0x1660b740a143664bULL}, {0}, {0}},
    {{0x96a29f10376ccbfeULL, 0xceacdddb12cf8790ULL, 0x114f4ca2deef76e0ULL, 0x0065a92d1de81f34ULL}, {0}, {0}},
    {{0xcf30d50a5871040dULL, 0x353ebe2ccbc4869bULL, 0x7367f823da7d672cULL, 0x1f11f06520253598ULL}, {0}, {0}},
    {{0x110852d17df0693eULL, 0x3bd1d1a39b6759baULL, 0xb437ce7b14a2c3ddULL, 0x26596f5c5dd5a5d1ULL}, {0}, {0}},
    {{0x6743db15af91860fULL, 0x8539c4163a5f1e70ULL, 0x7bf3056efcf8b6d3ULL, 0x16f49bc727e45a2fULL}, {0}, {0}},
    {{0xe1a4e7438dd39e5fULL, 0x568feaf7ea8b3dc5ULL, 0x9954175efb331bf4ULL, 0x1abe1deb45b3e311ULL}, {0}, {0}},
    {{0x020d34aea15fba59ULL, 0x9f5db92aaec5f102ULL, 0xd8993a74ca548b77ULL, 0x0e426ccab66984d1ULL}, {0}, {0}},
    {{0xa841924303f6a6c6ULL, 0x0071684b902d534fULL, 0x4933bd1942053f1fULL, 0x0e7c30c2e2e8957fULL}, {0}, {0}},
    {{0x4c76e1f31d3fc69dULL, 0x6166ded6e3528eadULL, 0x1622708fc7edff1dULL, 0x0812a017ca92cf0aULL}, {0}, {0}},
    {{0x2e276b47cf010d54ULL, 0x68afe5026edd7a9cULL, 0xbba949d1db960400ULL, 0x21a5ade3df2bc1b5ULL}, {0}, {0}},
    {{0x72b1a5233f8749ceULL, 0xbd101945f50e5afeULL, 0xad711bf1a058c6c6ULL, 0x01f3035463816c84ULL}, {0}, {0}},
    {{0x4dcaa82b0f0c1c8bULL, 0x8bf2f9398dbd0fdfULL, 0x028c2aafc2d06a5eULL, 0x0b115572f038c0e2ULL}, {0}, {0}},
    {{0x3460613b6ef59e2fULL, 0x27fc24db42bc910aULL, 0xf0ef255543f50d2eULL, 0x1c38ec0b99b62fd4ULL}, {0}, {0}},
    {{0xb1d0b254d880c53eULL, 0x2f5d314606a297d4ULL, 0x425c3ff1f4ac737bULL, 0x1c89c6d9666272e8ULL}, {0}, {0}},
    {{0x8b71e2311bb88f8fULL, 0x21ad4880097a5eb3ULL, 0xf6d44008ae4c042aULL, 0x03326e643580356bULL}, {0}, {0}},
    {{0x5bdde2299910a4c9ULL, 0x50f27a6434b5dcebULL, 0x67cee9ea0e51e3adULL, 0x268076b0054fb73fULL}, {0}, {0}},
    // Rounds 60-63 (full rounds)
    {{0x78d04aa6f8747ad0ULL, 0x5da18ea9d8e4f101ULL, 0x626ed93491bda32eULL, 0x1acd63c67fbc9ab1ULL},
     {0xca8c86cd2a28b5a5ULL, 0x1bf93375e2323ec3ULL, 0xc4e3144be58ef690ULL, 0x19f8a5d670e8ab66ULL},
     {0xe1cfbb5f7b9b6893ULL, 0x068193ea51f6c92aULL, 0x6efa40d2df10a011ULL, 0x1c0dc443519ad7a8ULL}},
    {{0x180e4c3224987d3dULL, 0xfbeab33cb4f6a2c4ULL, 0x50fe7190e421dc19ULL, 0x14b39e7aa4068dbeULL},
     {0xafb1e35e28b0795eULL, 0xb820fc519f01f021ULL, 0x8f28c63ea6c561b7ULL, 0x1d449b71bd826ec5ULL},
     {0x76524dc0a9e987fcULL, 0x89de141689d12522ULL, 0x60fa97fe60fe9d8eULL, 0x1ea2c9a89baaddbbULL}},
    {{0x134d5cefdb3c7ff1ULL, 0x591f9a46a0e9c058ULL, 0xb57e9c1c3d6a2bd7ULL, 0x0478d66d43535a8cULL},
     {0x1cde5e4a7b00bebeULL, 0x662e26ad86c400b2ULL, 0xf608f3b2717f9cd2ULL, 0x19272db71eece6a6ULL},
     {0x039be846af134166ULL, 0xb2dd1bd66a87ef75ULL, 0xc749c746f09208abULL, 0x14226537335cab33ULL}},
    {{0xf912f44961f9a9ceULL, 0xb21c21e4a1c2e823ULL, 0x9dfe38c0d976a088ULL, 0x01fd6af15956294fULL},
     {0x5ad8518d4e5f2a57ULL, 0xaee2e62ed229ba5aULL, 0x7bca190b8b2cab1aULL, 0x18e5abedd626ec30ULL},
     {0x0e2d54dc1c84fda6ULL, 0x97c021a3a409926dULL, 0xabbdffa6d3b35e32ULL, 0x0fc1bbceba0590f5ULL}}
};

/* ============================================================================
 * Poseidon2 Round Functions
 * ============================================================================ */

static void mds_external(poseidon_state_3 *state, const field_params *p) {
    bn254_fe sum;
    bn254_add(&sum, &state->elem[0], &state->elem[1], p);
    bn254_add(&sum, &sum, &state->elem[2], p);
    bn254_add(&state->elem[0], &state->elem[0], &sum, p);
    bn254_add(&state->elem[1], &state->elem[1], &sum, p);
    bn254_add(&state->elem[2], &state->elem[2], &sum, p);
}

static void mds_internal(poseidon_state_3 *state, const field_params *p) {
    bn254_fe sum, tmp0, tmp1, tmp2;
    bn254_add(&sum, &state->elem[0], &state->elem[1], p);
    bn254_add(&sum, &sum, &state->elem[2], p);

    bn254_add(&tmp0, &state->elem[0], &sum, p);
    bn254_add(&tmp1, &state->elem[1], &sum, p);
    bn254_add(&tmp2, &state->elem[2], &state->elem[2], p);
    bn254_add(&tmp2, &tmp2, &sum, p);

    bn254_copy(&state->elem[0], &tmp0);
    bn254_copy(&state->elem[1], &tmp1);
    bn254_copy(&state->elem[2], &tmp2);
}

static void full_round(poseidon_state_3 *state, int round, const field_params *p) {
    for (int i = 0; i < 3; i++) {
        bn254_fe rc;
        bn254_from_limbs(&rc, RC_3[round][i]);
        bn254_to_mont(&rc, &rc, p);
        bn254_add(&state->elem[i], &state->elem[i], &rc, p);
    }
    bn254_sbox5_full_round(state, p);
    mds_external(state, p);
}

static void partial_round(poseidon_state_3 *state, int round, const field_params *p) {
    bn254_fe rc;
    bn254_from_limbs(&rc, RC_3[round][0]);
    bn254_to_mont(&rc, &rc, p);
    bn254_add(&state->elem[0], &state->elem[0], &rc, p);

    bn254_sbox5_partial_round(state, p);
    mds_internal(state, p);
}

static void poseidon2_permutation(poseidon_state_3 *state, const field_params *p) {
    mds_external(state, p);

    for (int r = 0; r < 4; r++) {
        full_round(state, r, p);
    }

    for (int r = 4; r < 60; r++) {
        partial_round(state, r, p);
    }

    for (int r = 60; r < 64; r++) {
        full_round(state, r, p);
    }
}

/* ============================================================================
 * JSON Parsing (supports Rust-generated format)
 * ============================================================================ */

static const char* skip_ws(const char* p) {
    while (*p == ' ' || *p == '\n' || *p == '\r' || *p == '\t') p++;
    return p;
}

static bool parse_hex(const char** pp, bn254_fe* out) {
    const char* p = *pp;
    p = skip_ws(p);

    if (*p != '"') return false;
    p++;

    if (p[0] != '0' || p[1] != 'x') return false;
    p += 2;

    uint64_t limbs[4] = {0, 0, 0, 0};

    while ((*p >= '0' && *p <= '9') || (*p >= 'a' && *p <= 'f') || (*p >= 'A' && *p <= 'F')) {
        uint64_t digit;
        if (*p >= '0' && *p <= '9') digit = (uint64_t)(*p - '0');
        else if (*p >= 'a' && *p <= 'f') digit = (uint64_t)(*p - 'a' + 10);
        else digit = (uint64_t)(*p - 'A' + 10);

        uint64_t carry = digit;
        for (int i = 0; i < 4; i++) {
            uint64_t new_val = (limbs[i] << 4) | carry;
            carry = limbs[i] >> 60;
            limbs[i] = new_val;
        }
        p++;
    }

    if (*p != '"') return false;
    p++;

    bn254_from_limbs(out, limbs);
    *pp = p;
    return true;
}

static bool parse_vector(const char** pp, bn254_fe out[3]) {
    const char* p = *pp;
    p = skip_ws(p);

    if (*p != '[') return false;
    p++;

    for (int i = 0; i < 3; i++) {
        p = skip_ws(p);
        if (!parse_hex(&p, &out[i])) return false;
        p = skip_ws(p);
        if (i < 2) {
            if (*p != ',') return false;
            p++;
        }
    }

    p = skip_ws(p);
    if (*p != ']') return false;
    p++;

    *pp = p;
    return true;
}

static void print_hex(const bn254_fe* v) {
    printf("0x");
    for (int i = 3; i >= 0; i--) {
        printf("%016llx", (unsigned long long)v->limbs[i]);
    }
}

/* ============================================================================
 * Vector Processing
 * ============================================================================ */

typedef struct {
    int total;
    int passed;
    int failed;
    int first_fail_idx;
} Stats;

static void process_array(const char* json, const char* array_name,
                         const field_params* params, Stats* stats, bool verbose) {
    char search_key[64];
    snprintf(search_key, sizeof(search_key), "\"%s\"", array_name);

    const char* p = strstr(json, search_key);
    if (!p) return;

    p = strchr(p, '[');
    if (!p) return;
    p++;

    while (*p) {
        p = skip_ws(p);

        if (*p == ']') break;
        if (*p == ',') { p++; continue; }
        if (*p != '{') break;

        const char* input_start = strstr(p, "\"input\"");
        if (!input_start) break;
        input_start = strchr(input_start, '[');
        if (!input_start) break;

        const char* output_start = strstr(p, "\"output\"");
        if (!output_start) break;
        output_start = strchr(output_start, '[');
        if (!output_start) break;

        bn254_fe input[3], expected[3];
        if (!parse_vector(&input_start, input)) {
            fprintf(stderr, "Error parsing input at vector %d\n", stats->total);
            break;
        }

        if (!parse_vector(&output_start, expected)) {
            fprintf(stderr, "Error parsing output at vector %d\n", stats->total);
            break;
        }

        poseidon_state_3 state;
        for (int i = 0; i < 3; i++) {
            bn254_to_mont(&state.elem[i], &input[i], params);
        }

        poseidon2_permutation(&state, params);

        bn254_fe actual[3];
        for (int i = 0; i < 3; i++) {
            bn254_from_mont(&actual[i], &state.elem[i], params);
        }

        bool match = true;
        for (int i = 0; i < 3; i++) {
            if (!bn254_eq(&actual[i], &expected[i])) {
                match = false;
                break;
            }
        }

        stats->total++;
        if (match) {
            stats->passed++;
            if (verbose && (stats->total <= 5 || stats->total % 1000 == 0)) {
                printf("  [%s] Vector %5d: PASS\n", array_name, stats->total);
            }
        } else {
            if (stats->first_fail_idx == -1) {
                stats->first_fail_idx = stats->total;
            }
            stats->failed++;
            if (stats->failed <= 3) {
                printf("\n==== MISMATCH [%s] vector %d ====\n", array_name, stats->total);
                printf("Input:\n");
                for (int i = 0; i < 3; i++) {
                    printf("  [%d]: ", i); print_hex(&input[i]); printf("\n");
                }
                printf("Expected:\n");
                for (int i = 0; i < 3; i++) {
                    printf("  [%d]: ", i); print_hex(&expected[i]); printf("\n");
                }
                printf("Actual:\n");
                for (int i = 0; i < 3; i++) {
                    printf("  [%d]: ", i); print_hex(&actual[i]); printf("\n");
                }
                printf("================================\n\n");
            }
        }

        p = strchr(p, '}');
        if (p) p++;
    }
}

/* ============================================================================
 * Benchmark
 * ============================================================================ */

static double benchmark_permutation(const field_params* params, int iterations) {
    poseidon_state_3 state;

    // Initialize with a fixed input
    bn254_fe one;
    uint64_t one_limbs[4] = {1, 0, 0, 0};
    bn254_from_limbs(&one, one_limbs);
    bn254_to_mont(&one, &one, params);

    for (int i = 0; i < 3; i++) {
        bn254_copy(&state.elem[i], &one);
    }

    // Warmup
    for (int i = 0; i < 1000; i++) {
        poseidon_state_3 warmup = state;
        poseidon2_permutation(&warmup, params);
    }

    // Benchmark
    clock_t start = clock();
    for (int i = 0; i < iterations; i++) {
        poseidon_state_3 bench = state;
        poseidon2_permutation(&bench, params);
    }
    clock_t end = clock();

    double elapsed_sec = (double)(end - start) / CLOCKS_PER_SEC;
    return elapsed_sec;
}

/* ============================================================================
 * Main
 * ============================================================================ */

int main(int argc, char** argv) {
    bool run_benchmark = false;
    int bench_iterations = 1000000;
    const char* json_file = NULL;

    for (int i = 1; i < argc; i++) {
        if (strcmp(argv[i], "--bench") == 0) {
            run_benchmark = true;
            if (i + 1 < argc && argv[i+1][0] != '-') {
                bench_iterations = atoi(argv[++i]);
            }
        } else if (argv[i][0] != '-') {
            json_file = argv[i];
        }
    }

    field_params params;
    bn254_init_params(&params);

    printf("=================================================================\n");
    printf("  PHASE 4b Extended: Rust Oracle -> C Validation                 \n");
    printf("=================================================================\n\n");

    // Run validation if JSON file provided
    if (json_file) {
        FILE* f = fopen(json_file, "r");
        if (!f) {
            fprintf(stderr, "Error: Cannot open %s\n", json_file);
            return 1;
        }

        fseek(f, 0, SEEK_END);
        long size = ftell(f);
        fseek(f, 0, SEEK_SET);

        char* json = malloc((size_t)size + 1);
        if (!json) {
            fprintf(stderr, "Error: Cannot allocate memory\n");
            fclose(f);
            return 1;
        }
        size_t read_size = fread(json, 1, (size_t)size, f);
        json[read_size] = '\0';
        fclose(f);

        printf("Processing: %s\n", json_file);
        printf("File size: %.2f MB\n\n", (double)size / (1024 * 1024));

        Stats edge_stats = {0, 0, 0, -1};
        Stats random_stats = {0, 0, 0, -1};

        printf("Processing edge cases...\n");
        process_array(json, "edge_cases", &params, &edge_stats, true);
        printf("  Edge cases: %d/%d passed\n\n", edge_stats.passed, edge_stats.total);

        printf("Processing random cases...\n");
        process_array(json, "random_cases", &params, &random_stats, true);
        printf("  Random cases: %d/%d passed\n\n", random_stats.passed, random_stats.total);

        free(json);

        int total = edge_stats.total + random_stats.total;
        int passed = edge_stats.passed + random_stats.passed;
        int failed = edge_stats.failed + random_stats.failed;

        printf("=================================================================\n");
        printf("  VALIDATION RESULTS\n");
        printf("=================================================================\n");
        printf("  Edge cases:    %5d / %5d passed\n", edge_stats.passed, edge_stats.total);
        printf("  Random cases:  %5d / %5d passed\n", random_stats.passed, random_stats.total);
        printf("-----------------------------------------------------------------\n");
        printf("  TOTAL:         %5d / %5d passed\n", passed, total);

        if (failed > 0) {
            printf("\n  STATUS: FAILED (%d mismatches)\n", failed);
            printf("=================================================================\n");
            if (!run_benchmark) return 1;
        } else {
            printf("\n  STATUS: ALL TESTS PASSED\n");
            printf("  C implementation matches HorizenLabs Rust oracle!\n");
            printf("=================================================================\n");
        }
        printf("\n");
    }

    // Run benchmark if requested
    if (run_benchmark) {
        printf("=================================================================\n");
        printf("  BENCHMARK: C Implementation\n");
        printf("=================================================================\n");
        printf("  Iterations: %d\n", bench_iterations);
        printf("  Running...\n\n");

        double elapsed = benchmark_permutation(&params, bench_iterations);
        double per_hash_ns = (elapsed * 1e9) / bench_iterations;
        double hashes_per_sec = bench_iterations / elapsed;

        printf("  Total time:       %.3f seconds\n", elapsed);
        printf("  Per hash:         %.1f ns\n", per_hash_ns);
        printf("  Throughput:       %.0f hashes/second\n", hashes_per_sec);
        printf("  Throughput:       %.2f kH/s\n", hashes_per_sec / 1000.0);
        printf("=================================================================\n");

        // Machine-readable output for comparison
        printf("\nBENCHMARK_RESULT_C: %d %.1f %.0f\n", bench_iterations, per_hash_ns, hashes_per_sec);
    }

    if (!json_file && !run_benchmark) {
        printf("Usage: %s [vectors.json] [--bench [iterations]]\n", argv[0]);
        printf("\nOptions:\n");
        printf("  vectors.json      JSON file with test vectors\n");
        printf("  --bench [N]       Run benchmark with N iterations (default: 1M)\n");
        return 1;
    }

    return 0;
}
