/-
  Generate test vectors for differential fuzzing

  This generates random inputs and their expected x^5 outputs
  in the BN254 scalar field, to be compared against the C implementation.
-/

import Mathlib.Data.ZMod.Basic

namespace Poseidon.TestVectors

/-- BN254 scalar field prime -/
def BN254_P : Nat :=
  21888242871839275222246405745257275088548364400416034343698204186575808495617

/-- Simple PRNG for test vector generation -/
structure PRNG where
  state : UInt64
  deriving Repr

def PRNG.init (seed : UInt64) : PRNG := { state := seed }

def PRNG.next (prng : PRNG) : (UInt64 × PRNG) :=
  let x := prng.state
  let x := x ^^^ (x <<< 13)
  let x := x ^^^ (x >>> 7)
  let x := x ^^^ (x <<< 17)
  (x, { state := x })

/-- Generate a random 256-bit number (4 limbs) -/
def PRNG.random256 (prng : PRNG) : (Array UInt64 × PRNG) :=
  let (l0, prng) := prng.next
  let (l1, prng) := prng.next
  let (l2, prng) := prng.next
  let (l3, prng) := prng.next
  -- Clear top bits to keep under 2^254
  let l3 := l3 &&& 0x3FFFFFFFFFFFFFFF
  (#[l0, l1, l2, l3], prng)

/-- Convert 4 limbs to Nat -/
def limbs_to_nat (limbs : Array UInt64) : Nat :=
  limbs[0]!.toNat +
  limbs[1]!.toNat * (2^64) +
  limbs[2]!.toNat * (2^128) +
  limbs[3]!.toNat * (2^192)

/-- Convert Nat to 4 limbs -/
def nat_to_limbs (n : Nat) : Array UInt64 :=
  #[
    (n % 2^64).toUInt64,
    ((n / 2^64) % 2^64).toUInt64,
    ((n / 2^128) % 2^64).toUInt64,
    ((n / 2^192) % 2^64).toUInt64
  ]

/-- Compute x^5 mod p -/
def sbox5 (x : Nat) (p : Nat) : Nat :=
  let x2 := (x * x) % p
  let x4 := (x2 * x2) % p
  (x * x4) % p

/-- Format test vector as string -/
def format_vector (input output : Array UInt64) : String :=
  let fmt (a : Array UInt64) : String :=
    s!"{a[0]!.toNat.toDigits 16 |> String.mk} {a[1]!.toNat.toDigits 16 |> String.mk} {a[2]!.toNat.toDigits 16 |> String.mk} {a[3]!.toNat.toDigits 16 |> String.mk}"
  s!"INPUT: {fmt input} OUTPUT: {fmt output}"

/-- Generate n test vectors -/
def generate_vectors (n : Nat) (seed : UInt64) : List String :=
  let rec go (remaining : Nat) (prng : PRNG) (acc : List String) : List String :=
    if remaining = 0 then acc.reverse
    else
      let (limbs, prng) := prng.random256
      let x := limbs_to_nat limbs % BN254_P
      let y := sbox5 x BN254_P
      let input_limbs := nat_to_limbs x
      let output_limbs := nat_to_limbs y
      let line := format_vector input_limbs output_limbs
      go (remaining - 1) prng (line :: acc)
  go n (PRNG.init seed) []

/-- Main entry point -/
def main : IO Unit := do
  let n := 1000
  let seed : UInt64 := 0xDEADBEEF12345678
  let vectors := generate_vectors n seed

  IO.println s!"# Poseidon2 S-box Test Vectors"
  IO.println s!"# Generated by Lean specification"
  IO.println s!"# Count: {n}"
  IO.println s!"# Seed: {seed}"
  IO.println s!"# Format: INPUT: <x_l0> <x_l1> <x_l2> <x_l3> OUTPUT: <y_l0> <y_l1> <y_l2> <y_l3>"
  IO.println ""

  for v in vectors do
    IO.println v

end Poseidon.TestVectors
