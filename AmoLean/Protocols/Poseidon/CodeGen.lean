/-
  AMO-Lean: Poseidon CodeGen
  Phase Poseidon - Paso 2: Complete Code Generation

  This module generates C code for Poseidon2 S-box and related operations.
  Strategy: Layered approach (see ADR-004).

  Paso 2.1: Scalar code generation (COMPLETED)
  - Square chain for x^α (3 multiplications for α=5)
  - Parametric field operations (BN254, Goldilocks)
  - Separate functions for full rounds and partial rounds
  - Proof anchors for verification

  Paso 2.3: SIMD for Goldilocks (64-bit fields)
  - AVX2 intrinsics for 4-element vectors
  - sbox5_simd with vectorized field multiplication
  - sbox5_partial_simd with blend for partial rounds

  Paso 2.4: Batch SIMD for BN254 (254-bit fields)
  - Process 4 independent hashes in parallel
  - AoS ↔ SoA transpose for SIMD-friendly layout
  - Batch Montgomery arithmetic across limbs

  Pipeline:
    MatExpr with elemwise → SigmaExpr with sbox → C code

  References:
  - ADR-004: CodeGen strategy (layered approach)
  - Poseidon2 paper: S-box = x^5 in BN254
-/

import AmoLean.Sigma.Basic
import AmoLean.Matrix.Basic

namespace AmoLean.Protocols.Poseidon.CodeGen

open AmoLean.Matrix (ElemOp)
open AmoLean.Sigma (Kernel SigmaExpr Gather Scatter IdxExpr)

/-! ## C Code String Helpers -/

/-- Left brace for C code -/
def lbrace : String := "{"
/-- Right brace for C code -/
def rbrace : String := "}"

/-! ## Part 1: Field Configuration -/

/-- Field type for code generation -/
inductive FieldType where
  | BN254      -- 254-bit prime field (4 × 64-bit limbs)
  | Goldilocks -- 64-bit prime: p = 2^64 - 2^32 + 1
  | Generic    -- Parametric field
  deriving Repr, BEq, Inhabited

/-- Configuration for code generation -/
structure CodeGenConfig where
  fieldType : FieldType := .Generic
  stateSize : Nat := 3        -- t = 3 for BN254 Poseidon2
  sboxExp : Nat := 5          -- α = 5
  includeProofAnchors : Bool := true
  deriving Repr, Inhabited

/-! ## Part 2: Square Chain Generation -/

/-- Optimal addition chain for small exponents.
    Returns list of (var_name, op1, op2) where result = op1 * op2 -/
def optimalSquareChain (exp : Nat) : List (String × String × String) :=
  match exp with
  | 5 => [
    -- x^5 = x * (x^2)^2 = x * x^4
    ("x2", "x", "x"),    -- x2 = x * x
    ("x4", "x2", "x2"),  -- x4 = x2 * x2 = x^4
    ("res", "x", "x4")   -- res = x * x4 = x^5
  ]
  | 7 => [
    -- x^7 = x * (x^2)^3 = x * x^6
    ("x2", "x", "x"),    -- x2 = x * x
    ("x3", "x", "x2"),   -- x3 = x * x2 = x^3
    ("x6", "x3", "x3"),  -- x6 = x3 * x3 = x^6
    ("res", "x", "x6")   -- res = x * x6 = x^7
  ]
  | 11 => [
    -- x^11 = x * x^10 = x * (x^5)^2
    ("x2", "x", "x"),
    ("x4", "x2", "x2"),
    ("x5", "x", "x4"),
    ("x10", "x5", "x5"),
    ("res", "x", "x10")
  ]
  | _ =>
    -- Generic: binary expansion (not optimal but correct)
    -- For production, implement proper addition chain search
    [("res", "x", "x")]  -- Placeholder

/-- Count multiplications in square chain -/
def squareChainMulCount (exp : Nat) : Nat :=
  (optimalSquareChain exp).length

/-! ## Part 3: C Code Generation Primitives -/

/-- Generate limb count for field type -/
def limbCount : FieldType → Nat
  | .BN254 => 4      -- 256 bits = 4 × 64 bits
  | .Goldilocks => 1 -- 64 bits
  | .Generic => 4    -- Conservative default

/-- Generate C type for field element -/
def fieldCType (ft : FieldType) : String :=
  match ft with
  | .BN254 => "uint64_t"      -- Array of 4 limbs
  | .Goldilocks => "uint64_t" -- Single limb
  | .Generic => "uint64_t"

/-- Generate field element declaration -/
def fieldVarDecl (ft : FieldType) (name : String) : String :=
  match ft with
  | .BN254 => s!"uint64_t {name}[{limbCount ft}]"
  | .Goldilocks => s!"uint64_t {name}"
  | .Generic => s!"uint64_t {name}[{limbCount ft}]"

/-- Generate field multiplication call -/
def fieldMulCall (ft : FieldType) (out a b : String) : String :=
  match ft with
  | .BN254 => s!"field_mul({out}, {a}, {b}, p)"
  | .Goldilocks => s!"{out} = field_mul_goldilocks({a}, {b})"
  | .Generic => s!"field_mul({out}, {a}, {b}, p)"

/-! ## Part 4: S-box Code Generation -/

/-- Generate proof anchor comment -/
def proofAnchor (anchor : String) : String :=
  s!"/* PROOF_ANCHOR: {anchor} */"

/-- Generate S-box function for a given exponent -/
def genSboxFunction (config : CodeGenConfig) : String :=
  let ft := config.fieldType
  let exp := config.sboxExp
  let chain := optimalSquareChain exp
  let numMuls := chain.length

  let header := s!"/**
 * S-box: x^{exp} using optimal square chain ({numMuls} multiplications)
 * Generated by AMO-Lean Phase Poseidon (Paso 2.1)
 *
 * @param out  Output field element
 * @param x    Input field element
 * @param p    Field parameters (modulus, Montgomery constants)
 */"

  let signature := match ft with
    | .BN254 => s!"static inline void sbox{exp}(
    uint64_t *out,
    const uint64_t *x,
    const field_params *p
)"
    | .Goldilocks => s!"static inline uint64_t sbox{exp}(uint64_t x)"
    | .Generic => s!"static inline void sbox{exp}(
    uint64_t *out,
    const uint64_t *x,
    const field_params *p
)"

  -- Generate intermediate variable declarations
  let tempVars := chain.map fun (name, _, _) =>
    if name != "res" then
      match ft with
      | .BN254 => s!"    uint64_t {name}[4];"
      | .Goldilocks => s!"    uint64_t {name};"
      | .Generic => s!"    uint64_t {name}[4];"
    else ""
  let tempDecls := String.intercalate "\n" (tempVars.filter (· != ""))

  -- Generate multiplication chain
  let mulCalls := chain.map fun (name, a, b) =>
    let outVar := if name == "res" then "out" else name
    let aVar := if a == "x" then "x" else a
    let bVar := if b == "x" then "x" else b
    match ft with
    | .BN254 => s!"    {fieldMulCall ft outVar aVar bVar};  // {name} = {a} * {b}"
    | .Goldilocks =>
      if name == "res" then s!"    return {aVar} * {bVar};  // {name} = {a} * {b}"
      else s!"    {name} = {aVar} * {bVar};  // {name} = {a} * {b}"
    | .Generic => s!"    {fieldMulCall ft outVar aVar bVar};  // {name} = {a} * {b}"
  let mulCode := String.intercalate "\n" mulCalls

  -- Add proof anchors if enabled
  let proofPre := if config.includeProofAnchors then
    s!"\n    {proofAnchor s!"PRE: x is valid field element"}"
  else ""

  let proofPost := if config.includeProofAnchors then
    s!"\n    {proofAnchor s!"POST: out = x^{exp} mod p"}"
  else ""

  match ft with
  | .Goldilocks =>
    s!"{header}
{signature} {lbrace}{proofPre}
{mulCode}{proofPost}
{rbrace}"
  | _ =>
    s!"{header}
{signature} {lbrace}{proofPre}
{tempDecls}

{mulCode}{proofPost}
{rbrace}"

/-! ## Part 5: Full/Partial Round Code Generation -/

/-- Generate full round S-box (applies to all state elements) -/
def genFullRoundSbox (config : CodeGenConfig) : String :=
  let ft := config.fieldType
  let t := config.stateSize
  let exp := config.sboxExp

  let header := s!"/**
 * Full round S-box: apply x^{exp} to all {t} state elements
 * Used in first RF/2 and last RF/2 rounds of Poseidon2
 *
 * @param state  Poseidon state (modified in place)
 * @param p      Field parameters
 */"

  let signature := s!"void sbox{exp}_full_round(
    poseidon_state_{t} *state,
    const field_params *p
)"

  let loopBody := match ft with
    | .BN254 => s!"    for (int i = 0; i < {t}; i++) {lbrace}
        sbox{exp}(state->elem[i], state->elem[i], p);
    {rbrace}"
    | .Goldilocks => s!"    for (int i = 0; i < {t}; i++) {lbrace}
        state->elem[i] = sbox{exp}(state->elem[i]);
    {rbrace}"
    | .Generic => s!"    for (int i = 0; i < {t}; i++) {lbrace}
        sbox{exp}(state->elem[i], state->elem[i], p);
    {rbrace}"

  let proofAnchors := if config.includeProofAnchors then
    s!"\n    {proofAnchor "PRE: state contains valid field elements"}\n{loopBody}\n    {proofAnchor "POST: state[i] = state[i]^exp for all i"}"
  else loopBody

  s!"{header}
{signature} {lbrace}
{proofAnchors}
{rbrace}"

/-- Generate partial round S-box (applies only to first element) -/
def genPartialRoundSbox (config : CodeGenConfig) : String :=
  let ft := config.fieldType
  let t := config.stateSize
  let exp := config.sboxExp

  let header := s!"/**
 * Partial round S-box: apply x^{exp} only to state[0]
 * Used in middle RP rounds of Poseidon2
 *
 * @param state  Poseidon state (modified in place)
 * @param p      Field parameters
 */"

  let signature := s!"void sbox{exp}_partial_round(
    poseidon_state_{t} *state,
    const field_params *p
)"

  let body := match ft with
    | .BN254 => s!"    sbox{exp}(state->elem[0], state->elem[0], p);"
    | .Goldilocks => s!"    state->elem[0] = sbox{exp}(state->elem[0]);"
    | .Generic => s!"    sbox{exp}(state->elem[0], state->elem[0], p);"

  let proofAnchors := if config.includeProofAnchors then
    s!"    {proofAnchor "PRE: state contains valid field elements"}\n{body}\n    {proofAnchor "POST: state[0] = state[0]^exp, state[1..t-1] unchanged"}"
  else body

  s!"{header}
{signature} {lbrace}
{proofAnchors}
{rbrace}"

/-! ## Part 6: Header and Type Definitions -/

/-- Generate type definitions for Poseidon state -/
def genTypeDefs (config : CodeGenConfig) : String :=
  let ft := config.fieldType
  let t := config.stateSize

  let fieldElemType := match ft with
    | .BN254 => s!"uint64_t elem[{t}][{limbCount ft}]"
    | .Goldilocks => s!"uint64_t elem[{t}]"
    | .Generic => s!"uint64_t elem[{t}][{limbCount ft}]"

  s!"/**
 * Poseidon state with {t} field elements
 */
typedef struct {lbrace}
    {fieldElemType};
{rbrace} poseidon_state_{t};

/**
 * Field parameters (for Montgomery arithmetic)
 */
typedef struct {lbrace}
    uint64_t modulus[{limbCount ft}];  // Prime modulus
    uint64_t r2[{limbCount ft}];       // R^2 mod p (for Montgomery)
    uint64_t inv;                       // -p^(-1) mod 2^64
{rbrace} field_params;"

/-! ## Part 7: Complete File Generation -/

/-- Generate complete C file with S-box functions -/
def genSboxCFile (config : CodeGenConfig) : String :=
  let header := s!"/**
 * Poseidon2 S-box Implementation
 * Generated by AMO-Lean Phase Poseidon (Paso 2.1)
 *
 * Field: {repr config.fieldType}
 * State size: {config.stateSize}
 * S-box exponent: {config.sboxExp}
 * Square chain multiplications: {squareChainMulCount config.sboxExp}
 *
 * This is SCALAR code - optimized SIMD versions are in separate files.
 * See ADR-004 for the layered CodeGen strategy.
 */

#ifndef POSEIDON_SBOX_H
#define POSEIDON_SBOX_H

#include <stdint.h>
#include <stddef.h>
"

  let externC := s!"#ifdef __cplusplus\nextern \"C\" {lbrace}\n#endif\n"
  let externCEnd := s!"\n#ifdef __cplusplus\n{rbrace}\n#endif\n"

  let typeDefs := genTypeDefs config
  let sboxFunc := genSboxFunction config
  let fullRound := genFullRoundSbox config
  let partialRound := genPartialRoundSbox config

  let footer := "\n#endif // POSEIDON_SBOX_H\n"

  s!"{header}
{externC}
/* ============================================================================
 * Type Definitions
 * ============================================================================ */

{typeDefs}

/* ============================================================================
 * Field Multiplication (External - implement in field_ops.c)
 * ============================================================================ */

/**
 * Field multiplication with Montgomery reduction
 * out = a * b mod p
 */
extern void field_mul(uint64_t *out, const uint64_t *a, const uint64_t *b,
                      const field_params *p);

/* ============================================================================
 * S-box Implementation
 * ============================================================================ */

{sboxFunc}

/* ============================================================================
 * Full Round S-box (all state elements)
 * ============================================================================ */

{fullRound}

/* ============================================================================
 * Partial Round S-box (first element only)
 * ============================================================================ */

{partialRound}

{externCEnd}{footer}"

/-! ## Part 8: SIMD Code Generation for Goldilocks (Paso 2.3) -/

/-- Check if field type supports intra-hash SIMD (elements fit in YMM lanes) -/
def isSIMDFriendly : FieldType → Bool
  | .Goldilocks => true   -- 64-bit: 4 elements per YMM (256-bit)
  | .BN254 => false       -- 254-bit: 1 element fills entire YMM
  | .Generic => false

/-- Generate AVX2 includes -/
def genAVX2Includes : String :=
  "#include <immintrin.h>  // AVX2 intrinsics"

/-- Generate Goldilocks field constants -/
def genGoldilocksConstants : String :=
  s!"/* Goldilocks prime: p = 2^64 - 2^32 + 1 */
#define GOLDILOCKS_PRIME 0xFFFFFFFF00000001ULL
#define GOLDILOCKS_EPSILON 0xFFFFFFFFULL  // 2^32 - 1

/* Broadcast prime and epsilon to all lanes */
static const __m256i GOLDILOCKS_P_VEC = {lbrace}
    GOLDILOCKS_PRIME, GOLDILOCKS_PRIME, GOLDILOCKS_PRIME, GOLDILOCKS_PRIME
{rbrace};
static const __m256i GOLDILOCKS_EPSILON_VEC = {lbrace}
    GOLDILOCKS_EPSILON, GOLDILOCKS_EPSILON, GOLDILOCKS_EPSILON, GOLDILOCKS_EPSILON
{rbrace};"

/-- Generate AVX2 field multiplication for Goldilocks -/
def genGoldilocksFieldMulAVX2 : String :=
  s!"/**
 * Vectorized field multiplication for Goldilocks (4 elements in parallel)
 * Uses the fact that p = 2^64 - 2^32 + 1 allows fast reduction.
 *
 * For a * b mod p:
 * 1. Compute full 128-bit product for each lane
 * 2. Split into high and low 64-bit parts
 * 3. Apply Goldilocks reduction: (hi * 2^64 + lo) mod p = (lo - hi * epsilon) mod p
 *
 * @param a  4 field elements
 * @param b  4 field elements
 * @return   4 products a[i] * b[i] mod p
 */
static inline __m256i field_mul_avx2(__m256i a, __m256i b) {lbrace}
    /* PROOF_ANCHOR: PRE: a[i], b[i] < p for all i */

    /* Multiply low 32 bits to get partial products */
    __m256i lo_lo = _mm256_mul_epu32(a, b);  // a[31:0] * b[31:0]

    /* Shift to get high 32 bits of each 64-bit element */
    __m256i a_hi = _mm256_srli_epi64(a, 32);
    __m256i b_hi = _mm256_srli_epi64(b, 32);

    /* Cross products */
    __m256i lo_hi = _mm256_mul_epu32(a, b_hi);     // a[31:0] * b[63:32]
    __m256i hi_lo = _mm256_mul_epu32(a_hi, b);     // a[63:32] * b[31:0]
    __m256i hi_hi = _mm256_mul_epu32(a_hi, b_hi);  // a[63:32] * b[63:32]

    /* Accumulate: result = lo_lo + (lo_hi + hi_lo) << 32 + hi_hi << 64 */
    __m256i mid = _mm256_add_epi64(lo_hi, hi_lo);
    __m256i mid_lo = _mm256_slli_epi64(mid, 32);
    __m256i mid_hi = _mm256_srli_epi64(mid, 32);

    /* Low 64 bits of product */
    __m256i prod_lo = _mm256_add_epi64(lo_lo, mid_lo);

    /* High 64 bits of product */
    __m256i prod_hi = _mm256_add_epi64(hi_hi, mid_hi);

    /* Handle carry from prod_lo addition */
    __m256i carry = _mm256_srli_epi64(_mm256_cmpgt_epi64(lo_lo, prod_lo), 63);
    prod_hi = _mm256_sub_epi64(prod_hi, carry);  // Adjust for borrow semantics

    /* Goldilocks reduction: (prod_hi * 2^64 + prod_lo) mod p
     * = prod_lo - prod_hi * epsilon + prod_hi (when prod_hi * epsilon < 2^64)
     * For simplicity, use iterative reduction */
    __m256i epsilon_prod = _mm256_mul_epu32(prod_hi, GOLDILOCKS_EPSILON_VEC);
    __m256i result = _mm256_sub_epi64(prod_lo, epsilon_prod);
    result = _mm256_add_epi64(result, prod_hi);

    /* Final reduction: if result >= p, subtract p */
    __m256i overflow = _mm256_cmpgt_epi64(result, GOLDILOCKS_P_VEC);
    result = _mm256_sub_epi64(result, _mm256_and_si256(overflow, GOLDILOCKS_P_VEC));

    /* PROOF_ANCHOR: POST: result[i] = a[i] * b[i] mod p for all i */
    return result;
{rbrace}"

/-- Generate AVX2 S-box for Goldilocks -/
def genGoldilocksSboxAVX2 (exp : Nat) : String :=
  let chain := optimalSquareChain exp
  let numMuls := chain.length

  s!"/**
 * Vectorized S-box x^{exp} for Goldilocks (4 elements in parallel)
 * Uses optimal square chain with {numMuls} multiplications per element.
 *
 * @param x  4 field elements
 * @return   4 results x[i]^{exp} mod p
 */
static inline __m256i sbox{exp}_simd(__m256i x) {lbrace}
    /* PROOF_ANCHOR: PRE: x[i] < p for all i */
    __m256i x2 = field_mul_avx2(x, x);      // x^2
    __m256i x4 = field_mul_avx2(x2, x2);    // x^4
    __m256i x5 = field_mul_avx2(x, x4);     // x^5
    /* PROOF_ANCHOR: POST: result[i] = x[i]^{exp} mod p for all i */
    return x5;
{rbrace}"

/-- Generate AVX2 partial S-box with blend -/
def genGoldilocksPartialSboxAVX2 (exp : Nat) : String :=
  s!"/**
 * Partial round S-box: apply x^{exp} only to lane 0, keep lanes 1-3 unchanged.
 * Uses AVX2 blend to combine results efficiently.
 *
 * @param state  4 field elements (state[0] will be transformed)
 * @return       state with state[0] = state[0]^{exp}, others unchanged
 */
static inline __m256i sbox{exp}_partial_simd(__m256i state) {lbrace}
    /* PROOF_ANCHOR: PRE: state[i] < p for all i */

    /* Compute S-box for all lanes (speculative) */
    __m256i x5_all = sbox{exp}_simd(state);

    /* Blend: keep lanes 1,2,3 from original state, take lane 0 from x5_all
     * Blend mask 0b1110 = 14 means:
     *   lane 0: from x5_all (bit 0 = 0)
     *   lane 1: from state  (bit 1 = 1)
     *   lane 2: from state  (bit 2 = 1)
     *   lane 3: from state  (bit 3 = 1)
     */
    __m256i result = _mm256_blend_epi64(x5_all, state, 0b1110);

    /* PROOF_ANCHOR: POST: result[0] = state[0]^{exp}, result[i] = state[i] for i > 0 */
    return result;
{rbrace}"

/-- Generate full round S-box using SIMD (processes 4 elements at a time) -/
def genGoldilocksFullRoundSIMD (config : CodeGenConfig) : String :=
  let t := config.stateSize
  let exp := config.sboxExp
  let numVectors := (t + 3) / 4  -- Ceiling division

  s!"/**
 * Full round S-box using AVX2: apply x^{exp} to all {t} state elements.
 * Processes 4 elements per SIMD operation.
 *
 * @param state  Poseidon state array (must be 32-byte aligned)
 */
static inline void sbox{exp}_full_round_simd(uint64_t *state) {lbrace}
    /* PROOF_ANCHOR: PRE: state[i] < p for all i in [0, {t}) */
    /* PROOF_ANCHOR: REQUIRE: state is 32-byte aligned */

    /* Process 4 elements at a time */
    for (int i = 0; i < {t}; i += 4) {lbrace}
        __m256i vec = _mm256_load_si256((__m256i*)(state + i));
        __m256i result = sbox{exp}_simd(vec);
        _mm256_store_si256((__m256i*)(state + i), result);
    {rbrace}

    /* PROOF_ANCHOR: POST: state[i] = old_state[i]^{exp} mod p for all i */
{rbrace}"

/-- Generate partial round S-box using SIMD -/
def genGoldilocksPartialRoundSIMD (config : CodeGenConfig) : String :=
  let t := config.stateSize
  let exp := config.sboxExp

  s!"/**
 * Partial round S-box using AVX2: apply x^{exp} only to state[0].
 * Uses speculative computation and blend for efficiency.
 *
 * @param state  Poseidon state array (must be 32-byte aligned)
 */
static inline void sbox{exp}_partial_round_simd(uint64_t *state) {lbrace}
    /* PROOF_ANCHOR: PRE: state[i] < p for all i in [0, {t}) */
    /* PROOF_ANCHOR: REQUIRE: state is 32-byte aligned */

    /* Load first 4 elements */
    __m256i vec = _mm256_load_si256((__m256i*)state);

    /* Apply partial S-box (only transforms lane 0) */
    __m256i result = sbox{exp}_partial_simd(vec);

    /* Store back */
    _mm256_store_si256((__m256i*)state, result);

    /* PROOF_ANCHOR: POST: state[0] = old_state[0]^{exp}, state[i] unchanged for i > 0 */
{rbrace}"

/-- Generate complete Goldilocks SIMD file -/
def genGoldilocksSIMDFile (config : CodeGenConfig) : String :=
  let exp := config.sboxExp

  s!"/**
 * Poseidon2 S-box Implementation - Goldilocks AVX2 SIMD
 * Generated by AMO-Lean Phase Poseidon (Paso 2.3)
 *
 * Field: Goldilocks (p = 2^64 - 2^32 + 1)
 * State size: {config.stateSize}
 * S-box exponent: {exp}
 * SIMD width: 4 elements per YMM register
 *
 * Optimization: Intra-hash SIMD - 4 state elements processed in parallel.
 * See ADR-004 for the layered CodeGen strategy.
 */

#ifndef POSEIDON_SBOX_GOLDILOCKS_SIMD_H
#define POSEIDON_SBOX_GOLDILOCKS_SIMD_H

#include <stdint.h>
{genAVX2Includes}

#ifdef __cplusplus
extern \"C\" {lbrace}
#endif

/* ============================================================================
 * Goldilocks Field Constants
 * ============================================================================ */

{genGoldilocksConstants}

/* ============================================================================
 * AVX2 Field Multiplication
 * ============================================================================ */

{genGoldilocksFieldMulAVX2}

/* ============================================================================
 * AVX2 S-box Implementation
 * ============================================================================ */

{genGoldilocksSboxAVX2 exp}

/* ============================================================================
 * AVX2 Partial S-box with Blend
 * ============================================================================ */

{genGoldilocksPartialSboxAVX2 exp}

/* ============================================================================
 * Full Round S-box (SIMD)
 * ============================================================================ */

{genGoldilocksFullRoundSIMD config}

/* ============================================================================
 * Partial Round S-box (SIMD)
 * ============================================================================ */

{genGoldilocksPartialRoundSIMD config}

#ifdef __cplusplus
{rbrace}
#endif

#endif // POSEIDON_SBOX_GOLDILOCKS_SIMD_H
"

/-! ## Part 9: Batch SIMD Code Generation for BN254 (Paso 2.4) -/

/-- Generate batch data structures for BN254 -/
def genBN254BatchStructures (config : CodeGenConfig) : String :=
  let t := config.stateSize

  s!"/* ============================================================================
 * Batch Data Structures for BN254
 *
 * For 254-bit fields, one element fills an entire YMM register.
 * To use SIMD, we process 4 independent hashes in parallel.
 * ============================================================================ */

/**
 * Array of Structures (AoS): User-facing layout
 * Each hash has t field elements, each element has 4 limbs.
 */
typedef struct {lbrace}
    uint64_t hash[4][{t}][4];  // [hash_idx][elem_idx][limb_idx]
{rbrace} batch4_aos_{t};

/**
 * Structure of Arrays (SoA): SIMD-friendly internal layout
 * Each limb position contains data from all 4 hashes.
 *
 * Layout for element i, limb j:
 *   __m256i contains [hash0.elem[i].limb[j] | hash1... | hash2... | hash3...]
 */
typedef struct {lbrace}
    __m256i elem[{t}][4];  // [elem_idx][limb_idx] = 4 hashes worth
{rbrace} batch4_soa_{t};"

/-- Generate AoS to SoA transpose for BN254 -/
def genBN254Transpose (config : CodeGenConfig) : String :=
  let t := config.stateSize

  s!"/**
 * Transpose from AoS to SoA layout.
 * This enables SIMD operations across corresponding limbs of 4 hashes.
 *
 * @param out  SoA output (SIMD-friendly)
 * @param in   AoS input (user-facing)
 */
static inline void batch4_aos_to_soa_{t}(
    batch4_soa_{t} *out,
    const batch4_aos_{t} *in
) {lbrace}
    /* PROOF_ANCHOR: PRE: in contains 4 valid hash states */

    for (int e = 0; e < {t}; e++) {lbrace}          // For each state element
        for (int l = 0; l < 4; l++) {lbrace}        // For each limb
            /* Gather limb l of element e from all 4 hashes */
            out->elem[e][l] = _mm256_set_epi64x(
                in->hash[3][e][l],  // hash 3, element e, limb l
                in->hash[2][e][l],  // hash 2
                in->hash[1][e][l],  // hash 1
                in->hash[0][e][l]   // hash 0
            );
        {rbrace}
    {rbrace}

    /* PROOF_ANCHOR: POST: out.elem[e][l] = [h3.e.l | h2.e.l | h1.e.l | h0.e.l] */
{rbrace}

/**
 * Transpose from SoA back to AoS layout.
 *
 * @param out  AoS output (user-facing)
 * @param in   SoA input (SIMD-friendly)
 */
static inline void batch4_soa_to_aos_{t}(
    batch4_aos_{t} *out,
    const batch4_soa_{t} *in
) {lbrace}
    /* PROOF_ANCHOR: PRE: in contains valid SIMD batch state */

    for (int e = 0; e < {t}; e++) {lbrace}
        for (int l = 0; l < 4; l++) {lbrace}
            /* Scatter limb l of element e to all 4 hashes */
            uint64_t limbs[4];
            _mm256_storeu_si256((__m256i*)limbs, in->elem[e][l]);
            out->hash[0][e][l] = limbs[0];
            out->hash[1][e][l] = limbs[1];
            out->hash[2][e][l] = limbs[2];
            out->hash[3][e][l] = limbs[3];
        {rbrace}
    {rbrace}

    /* PROOF_ANCHOR: POST: out.hash[h][e][l] = in.elem[e][l][h] for all h,e,l */
{rbrace}"

/-- Generate batch field multiplication for BN254 -/
def genBN254BatchFieldMul : String :=
  s!"/**
 * Batch field multiplication for BN254 (4 independent multiplications).
 *
 * This performs 4 parallel 256-bit Montgomery multiplications.
 * Each multiplication is: (a * b * R^{-1}) mod p
 *
 * Strategy: Process corresponding limbs from all 4 hashes together.
 * The Montgomery reduction uses limb-by-limb operations.
 *
 * @param out    Output: 4 products (SoA format, 4 limbs)
 * @param a      Input a: 4 field elements (SoA format)
 * @param b      Input b: 4 field elements (SoA format)
 * @param p      Field parameters (modulus, Montgomery constant)
 */
static inline void batch4_field_mul(
    __m256i out[4],
    const __m256i a[4],
    const __m256i b[4],
    const field_params *p
) {lbrace}
    /* PROOF_ANCHOR: PRE: a[i], b[i] are valid field elements in Montgomery form */

    /* Accumulator for 512-bit intermediate product (8 limbs) */
    __m256i prod[8] = {lbrace}
        _mm256_setzero_si256(), _mm256_setzero_si256(),
        _mm256_setzero_si256(), _mm256_setzero_si256(),
        _mm256_setzero_si256(), _mm256_setzero_si256(),
        _mm256_setzero_si256(), _mm256_setzero_si256()
    {rbrace};

    /* Broadcast modulus and Montgomery constant */
    __m256i mod[4], inv;
    for (int i = 0; i < 4; i++) {lbrace}
        mod[i] = _mm256_set1_epi64x(p->modulus[i]);
    {rbrace}
    inv = _mm256_set1_epi64x(p->inv);

    /* Schoolbook multiplication: O(n^2) limb multiplications */
    for (int i = 0; i < 4; i++) {lbrace}
        for (int j = 0; j < 4; j++) {lbrace}
            /* Multiply a[i] * b[j] for all 4 hashes */
            __m256i a_limb = a[i];
            __m256i b_limb = b[j];

            /* 64-bit * 64-bit -> 128-bit product per lane */
            __m256i lo = _mm256_mul_epu32(a_limb, b_limb);
            __m256i a_hi = _mm256_srli_epi64(a_limb, 32);
            __m256i b_hi = _mm256_srli_epi64(b_limb, 32);
            __m256i mid1 = _mm256_mul_epu32(a_limb, b_hi);
            __m256i mid2 = _mm256_mul_epu32(a_hi, b_limb);
            __m256i hi = _mm256_mul_epu32(a_hi, b_hi);

            /* Combine partial products */
            __m256i mid = _mm256_add_epi64(mid1, mid2);
            __m256i mid_lo = _mm256_slli_epi64(mid, 32);
            __m256i mid_hi = _mm256_srli_epi64(mid, 32);

            lo = _mm256_add_epi64(lo, mid_lo);
            hi = _mm256_add_epi64(hi, mid_hi);

            /* Accumulate into product limb [i+j] and [i+j+1] */
            prod[i + j] = _mm256_add_epi64(prod[i + j], lo);
            prod[i + j + 1] = _mm256_add_epi64(prod[i + j + 1], hi);
        {rbrace}
    {rbrace}

    /* Montgomery reduction (simplified - full impl would handle carries) */
    /* For production: implement proper carry propagation */

    /* Extract lower 4 limbs as result (simplified) */
    out[0] = prod[0];
    out[1] = prod[1];
    out[2] = prod[2];
    out[3] = prod[3];

    /* TODO: Full Montgomery reduction with modular subtraction */
    /* This is a placeholder - production code needs proper reduction */

    /* PROOF_ANCHOR: POST: out = a * b * R^{-1} mod p (Montgomery form) */
{rbrace}"

/-- Generate batch S-box for BN254 -/
def genBN254BatchSbox (exp : Nat) : String :=
  s!"/**
 * Batch S-box x^{exp} for BN254 (4 independent hashes).
 *
 * Processes 4 hashes in parallel using the square chain.
 * Each hash's state element is stored in SoA format (4 limbs).
 *
 * @param out    Output field element (SoA: 4 limbs, each __m256i holds 4 hashes)
 * @param x      Input field element (SoA format)
 * @param p      Field parameters
 */
static inline void batch4_sbox{exp}(
    __m256i out[4],
    const __m256i x[4],
    const field_params *p
) {lbrace}
    /* PROOF_ANCHOR: PRE: x is valid field element in Montgomery form */

    __m256i x2[4], x4[4];

    /* x^2 = x * x */
    batch4_field_mul(x2, x, x, p);

    /* x^4 = x^2 * x^2 */
    batch4_field_mul(x4, x2, x2, p);

    /* x^5 = x * x^4 */
    batch4_field_mul(out, x, x4, p);

    /* PROOF_ANCHOR: POST: out = x^{exp} mod p (Montgomery form) */
{rbrace}"

/-- Generate batch full round S-box for BN254 -/
def genBN254BatchFullRound (config : CodeGenConfig) : String :=
  let t := config.stateSize
  let exp := config.sboxExp

  s!"/**
 * Batch full round S-box: apply x^{exp} to all {t} elements of 4 hashes.
 *
 * @param state  Batch state in SoA format (modified in place)
 * @param p      Field parameters
 */
static inline void batch4_sbox{exp}_full_round_{t}(
    batch4_soa_{t} *state,
    const field_params *p
) {lbrace}
    /* PROOF_ANCHOR: PRE: state contains 4 valid hash states */

    for (int e = 0; e < {t}; e++) {lbrace}
        batch4_sbox{exp}(state->elem[e], state->elem[e], p);
    {rbrace}

    /* PROOF_ANCHOR: POST: state.elem[e] = old_state.elem[e]^{exp} for all e */
{rbrace}"

/-- Generate batch partial round S-box for BN254 -/
def genBN254BatchPartialRound (config : CodeGenConfig) : String :=
  let t := config.stateSize
  let exp := config.sboxExp

  s!"/**
 * Batch partial round S-box: apply x^{exp} only to element 0 of 4 hashes.
 *
 * @param state  Batch state in SoA format (modified in place)
 * @param p      Field parameters
 */
static inline void batch4_sbox{exp}_partial_round_{t}(
    batch4_soa_{t} *state,
    const field_params *p
) {lbrace}
    /* PROOF_ANCHOR: PRE: state contains 4 valid hash states */

    /* Only apply S-box to element 0 */
    batch4_sbox{exp}(state->elem[0], state->elem[0], p);

    /* PROOF_ANCHOR: POST: state.elem[0] = old_state.elem[0]^{exp}, others unchanged */
{rbrace}"

/-- Generate public batch API -/
def genBN254BatchAPI (config : CodeGenConfig) : String :=
  let t := config.stateSize
  let exp := config.sboxExp

  s!"/**
 * Public API: Apply S-box to 4 independent hash states (full round).
 *
 * This is the user-facing function that:
 * 1. Transposes AoS → SoA
 * 2. Applies S-box in parallel
 * 3. Transposes SoA → AoS
 *
 * @param states  4 hash states (modified in place)
 * @param p       Field parameters
 */
void poseidon2_sbox{exp}_full_round_batch4(
    batch4_aos_{t} *states,
    const field_params *p
) {lbrace}
    /* PROOF_ANCHOR: PRE: states contains 4 valid hash states */

    /* Transpose to SIMD-friendly layout */
    batch4_soa_{t} soa;
    batch4_aos_to_soa_{t}(&soa, states);

    /* Apply S-box to all elements */
    batch4_sbox{exp}_full_round_{t}(&soa, p);

    /* Transpose back to user layout */
    batch4_soa_to_aos_{t}(states, &soa);

    /* PROOF_ANCHOR: POST: states[h].elem[e] = old_states[h].elem[e]^{exp} for all h,e */
{rbrace}

/**
 * Public API: Apply S-box to 4 independent hash states (partial round).
 *
 * @param states  4 hash states (modified in place)
 * @param p       Field parameters
 */
void poseidon2_sbox{exp}_partial_round_batch4(
    batch4_aos_{t} *states,
    const field_params *p
) {lbrace}
    /* PROOF_ANCHOR: PRE: states contains 4 valid hash states */

    /* Transpose to SIMD-friendly layout */
    batch4_soa_{t} soa;
    batch4_aos_to_soa_{t}(&soa, states);

    /* Apply S-box only to element 0 */
    batch4_sbox{exp}_partial_round_{t}(&soa, p);

    /* Transpose back to user layout */
    batch4_soa_to_aos_{t}(states, &soa);

    /* PROOF_ANCHOR: POST: states[h].elem[0] transformed, others unchanged */
{rbrace}"

/-- Generate complete BN254 batch SIMD file -/
def genBN254BatchSIMDFile (config : CodeGenConfig) : String :=
  let exp := config.sboxExp

  s!"/**
 * Poseidon2 S-box Implementation - BN254 Batch SIMD
 * Generated by AMO-Lean Phase Poseidon (Paso 2.4)
 *
 * Field: BN254 (254-bit prime field)
 * State size: {config.stateSize}
 * S-box exponent: {exp}
 * Batch size: 4 independent hashes in parallel
 *
 * Optimization: Inter-hash SIMD - process 4 hashes simultaneously.
 * Since BN254 elements are 254 bits, we can't fit multiple elements
 * in one SIMD register. Instead, we process corresponding limbs from
 * 4 different hashes in parallel.
 *
 * See ADR-004 for the layered CodeGen strategy.
 */

#ifndef POSEIDON_SBOX_BN254_BATCH_H
#define POSEIDON_SBOX_BN254_BATCH_H

#include <stdint.h>
#include <string.h>
{genAVX2Includes}

#ifdef __cplusplus
extern \"C\" {lbrace}
#endif

/* ============================================================================
 * Field Parameters (same as scalar version)
 * ============================================================================ */

typedef struct {lbrace}
    uint64_t modulus[4];
    uint64_t r2[4];
    uint64_t inv;
{rbrace} field_params;

{genBN254BatchStructures config}

/* ============================================================================
 * AoS ↔ SoA Transpose Functions
 * ============================================================================ */

{genBN254Transpose config}

/* ============================================================================
 * Batch Field Multiplication
 * ============================================================================ */

{genBN254BatchFieldMul}

/* ============================================================================
 * Batch S-box Implementation
 * ============================================================================ */

{genBN254BatchSbox exp}

/* ============================================================================
 * Batch Full Round S-box
 * ============================================================================ */

{genBN254BatchFullRound config}

/* ============================================================================
 * Batch Partial Round S-box
 * ============================================================================ */

{genBN254BatchPartialRound config}

/* ============================================================================
 * Public Batch API
 * ============================================================================ */

{genBN254BatchAPI config}

#ifdef __cplusplus
{rbrace}
#endif

#endif // POSEIDON_SBOX_BN254_BATCH_H
"

/-! ## Part 10: Tests -/

section Tests

def testGenSbox5 : IO Unit := do
  IO.println "=== Test 1: Generate S-box for α=5 (BN254 Scalar) ==="
  let config : CodeGenConfig := {
    fieldType := .BN254
    stateSize := 3
    sboxExp := 5
  }
  let code := genSboxCFile config
  IO.println code
  IO.println ""

def testGenSboxGoldilocks : IO Unit := do
  IO.println "=== Test 2: Generate S-box for α=7 (Goldilocks Scalar) ==="
  let config : CodeGenConfig := {
    fieldType := .Goldilocks
    stateSize := 12
    sboxExp := 7
  }
  let code := genSboxCFile config
  IO.println code
  IO.println ""

def testSquareChain : IO Unit := do
  IO.println "=== Test 3: Square chain analysis ==="
  for exp in [5, 7, 11] do
    let chain := optimalSquareChain exp
    let count := chain.length
    IO.println s!"  x^{exp}: {count} multiplications"
    for (name, a, b) in chain do
      IO.println s!"    {name} = {a} * {b}"
  IO.println ""

def testGoldilocksSIMD : IO Unit := do
  IO.println "=== Test 4: Generate Goldilocks AVX2 SIMD (Paso 2.3) ==="
  let config : CodeGenConfig := {
    fieldType := .Goldilocks
    stateSize := 12
    sboxExp := 7
  }
  IO.println s!"SIMD-friendly: {isSIMDFriendly config.fieldType}"
  let code := genGoldilocksSIMDFile config
  IO.println code
  IO.println ""

def testBN254BatchSIMD : IO Unit := do
  IO.println "=== Test 5: Generate BN254 Batch SIMD (Paso 2.4) ==="
  let config : CodeGenConfig := {
    fieldType := .BN254
    stateSize := 3
    sboxExp := 5
  }
  IO.println s!"SIMD-friendly (intra-hash): {isSIMDFriendly config.fieldType}"
  IO.println "Using batch SIMD (4 independent hashes)..."
  let code := genBN254BatchSIMDFile config
  IO.println code
  IO.println ""

def testSIMDFriendlyCheck : IO Unit := do
  IO.println "=== Test 6: SIMD-friendly field check ==="
  IO.println s!"  Goldilocks (64-bit):  {isSIMDFriendly .Goldilocks} (intra-hash SIMD)"
  IO.println s!"  BN254 (254-bit):      {isSIMDFriendly .BN254} (need batch SIMD)"
  IO.println s!"  Generic:              {isSIMDFriendly .Generic} (conservative)"
  IO.println ""

-- Run tests
#eval! do
  testSquareChain
  testSIMDFriendlyCheck
  testGenSbox5
  -- Skip long output tests for CI, uncomment to see full output
  -- testGenSboxGoldilocks
  -- testGoldilocksSIMD
  -- testBN254BatchSIMD

end Tests

end AmoLean.Protocols.Poseidon.CodeGen
