/-
  AMO-Lean: Poseidon CodeGen
  Phase Poseidon - Paso 2.1: Scalar Code Generation

  This module generates C code for Poseidon2 S-box and related operations.
  Strategy: Scalar correctness first, SIMD optimization later (see ADR-004).

  Generated code features:
  - Square chain for x^α (3 multiplications for α=5)
  - Parametric field operations (BN254, Goldilocks)
  - Separate functions for full rounds and partial rounds
  - Proof anchors for verification

  Pipeline:
    MatExpr with elemwise → SigmaExpr with sbox → C code

  References:
  - ADR-004: CodeGen strategy (layered approach)
  - Poseidon2 paper: S-box = x^5 in BN254
-/

import AmoLean.Sigma.Basic
import AmoLean.Matrix.Basic

namespace AmoLean.Protocols.Poseidon.CodeGen

open AmoLean.Matrix (ElemOp)
open AmoLean.Sigma (Kernel SigmaExpr Gather Scatter IdxExpr)

/-! ## C Code String Helpers -/

/-- Left brace for C code -/
def lbrace : String := "{"
/-- Right brace for C code -/
def rbrace : String := "}"

/-! ## Part 1: Field Configuration -/

/-- Field type for code generation -/
inductive FieldType where
  | BN254      -- 254-bit prime field (4 × 64-bit limbs)
  | Goldilocks -- 64-bit prime: p = 2^64 - 2^32 + 1
  | Generic    -- Parametric field
  deriving Repr, BEq, Inhabited

/-- Configuration for code generation -/
structure CodeGenConfig where
  fieldType : FieldType := .Generic
  stateSize : Nat := 3        -- t = 3 for BN254 Poseidon2
  sboxExp : Nat := 5          -- α = 5
  includeProofAnchors : Bool := true
  deriving Repr, Inhabited

/-! ## Part 2: Square Chain Generation -/

/-- Optimal addition chain for small exponents.
    Returns list of (var_name, op1, op2) where result = op1 * op2 -/
def optimalSquareChain (exp : Nat) : List (String × String × String) :=
  match exp with
  | 5 => [
    -- x^5 = x * (x^2)^2 = x * x^4
    ("x2", "x", "x"),    -- x2 = x * x
    ("x4", "x2", "x2"),  -- x4 = x2 * x2 = x^4
    ("res", "x", "x4")   -- res = x * x4 = x^5
  ]
  | 7 => [
    -- x^7 = x * (x^2)^3 = x * x^6
    ("x2", "x", "x"),    -- x2 = x * x
    ("x3", "x", "x2"),   -- x3 = x * x2 = x^3
    ("x6", "x3", "x3"),  -- x6 = x3 * x3 = x^6
    ("res", "x", "x6")   -- res = x * x6 = x^7
  ]
  | 11 => [
    -- x^11 = x * x^10 = x * (x^5)^2
    ("x2", "x", "x"),
    ("x4", "x2", "x2"),
    ("x5", "x", "x4"),
    ("x10", "x5", "x5"),
    ("res", "x", "x10")
  ]
  | _ =>
    -- Generic: binary expansion (not optimal but correct)
    -- For production, implement proper addition chain search
    [("res", "x", "x")]  -- Placeholder

/-- Count multiplications in square chain -/
def squareChainMulCount (exp : Nat) : Nat :=
  (optimalSquareChain exp).length

/-! ## Part 3: C Code Generation Primitives -/

/-- Generate limb count for field type -/
def limbCount : FieldType → Nat
  | .BN254 => 4      -- 256 bits = 4 × 64 bits
  | .Goldilocks => 1 -- 64 bits
  | .Generic => 4    -- Conservative default

/-- Generate C type for field element -/
def fieldCType (ft : FieldType) : String :=
  match ft with
  | .BN254 => "uint64_t"      -- Array of 4 limbs
  | .Goldilocks => "uint64_t" -- Single limb
  | .Generic => "uint64_t"

/-- Generate field element declaration -/
def fieldVarDecl (ft : FieldType) (name : String) : String :=
  match ft with
  | .BN254 => s!"uint64_t {name}[{limbCount ft}]"
  | .Goldilocks => s!"uint64_t {name}"
  | .Generic => s!"uint64_t {name}[{limbCount ft}]"

/-- Generate field multiplication call -/
def fieldMulCall (ft : FieldType) (out a b : String) : String :=
  match ft with
  | .BN254 => s!"field_mul({out}, {a}, {b}, p)"
  | .Goldilocks => s!"{out} = field_mul_goldilocks({a}, {b})"
  | .Generic => s!"field_mul({out}, {a}, {b}, p)"

/-! ## Part 4: S-box Code Generation -/

/-- Generate proof anchor comment -/
def proofAnchor (anchor : String) : String :=
  s!"/* PROOF_ANCHOR: {anchor} */"

/-- Generate S-box function for a given exponent -/
def genSboxFunction (config : CodeGenConfig) : String :=
  let ft := config.fieldType
  let exp := config.sboxExp
  let chain := optimalSquareChain exp
  let numMuls := chain.length

  let header := s!"/**
 * S-box: x^{exp} using optimal square chain ({numMuls} multiplications)
 * Generated by AMO-Lean Phase Poseidon (Paso 2.1)
 *
 * @param out  Output field element
 * @param x    Input field element
 * @param p    Field parameters (modulus, Montgomery constants)
 */"

  let signature := match ft with
    | .BN254 => s!"static inline void sbox{exp}(
    uint64_t *out,
    const uint64_t *x,
    const field_params *p
)"
    | .Goldilocks => s!"static inline uint64_t sbox{exp}(uint64_t x)"
    | .Generic => s!"static inline void sbox{exp}(
    uint64_t *out,
    const uint64_t *x,
    const field_params *p
)"

  -- Generate intermediate variable declarations
  let tempVars := chain.map fun (name, _, _) =>
    if name != "res" then
      match ft with
      | .BN254 => s!"    uint64_t {name}[4];"
      | .Goldilocks => s!"    uint64_t {name};"
      | .Generic => s!"    uint64_t {name}[4];"
    else ""
  let tempDecls := String.intercalate "\n" (tempVars.filter (· != ""))

  -- Generate multiplication chain
  let mulCalls := chain.map fun (name, a, b) =>
    let outVar := if name == "res" then "out" else name
    let aVar := if a == "x" then "x" else a
    let bVar := if b == "x" then "x" else b
    match ft with
    | .BN254 => s!"    {fieldMulCall ft outVar aVar bVar};  // {name} = {a} * {b}"
    | .Goldilocks =>
      if name == "res" then s!"    return {aVar} * {bVar};  // {name} = {a} * {b}"
      else s!"    {name} = {aVar} * {bVar};  // {name} = {a} * {b}"
    | .Generic => s!"    {fieldMulCall ft outVar aVar bVar};  // {name} = {a} * {b}"
  let mulCode := String.intercalate "\n" mulCalls

  -- Add proof anchors if enabled
  let proofPre := if config.includeProofAnchors then
    s!"\n    {proofAnchor s!"PRE: x is valid field element"}"
  else ""

  let proofPost := if config.includeProofAnchors then
    s!"\n    {proofAnchor s!"POST: out = x^{exp} mod p"}"
  else ""

  match ft with
  | .Goldilocks =>
    s!"{header}
{signature} {lbrace}{proofPre}
{mulCode}{proofPost}
{rbrace}"
  | _ =>
    s!"{header}
{signature} {lbrace}{proofPre}
{tempDecls}

{mulCode}{proofPost}
{rbrace}"

/-! ## Part 5: Full/Partial Round Code Generation -/

/-- Generate full round S-box (applies to all state elements) -/
def genFullRoundSbox (config : CodeGenConfig) : String :=
  let ft := config.fieldType
  let t := config.stateSize
  let exp := config.sboxExp

  let header := s!"/**
 * Full round S-box: apply x^{exp} to all {t} state elements
 * Used in first RF/2 and last RF/2 rounds of Poseidon2
 *
 * @param state  Poseidon state (modified in place)
 * @param p      Field parameters
 */"

  let signature := s!"void sbox{exp}_full_round(
    poseidon_state_{t} *state,
    const field_params *p
)"

  let loopBody := match ft with
    | .BN254 => s!"    for (int i = 0; i < {t}; i++) {lbrace}
        sbox{exp}(state->elem[i], state->elem[i], p);
    {rbrace}"
    | .Goldilocks => s!"    for (int i = 0; i < {t}; i++) {lbrace}
        state->elem[i] = sbox{exp}(state->elem[i]);
    {rbrace}"
    | .Generic => s!"    for (int i = 0; i < {t}; i++) {lbrace}
        sbox{exp}(state->elem[i], state->elem[i], p);
    {rbrace}"

  let proofAnchors := if config.includeProofAnchors then
    s!"\n    {proofAnchor "PRE: state contains valid field elements"}\n{loopBody}\n    {proofAnchor "POST: state[i] = state[i]^exp for all i"}"
  else loopBody

  s!"{header}
{signature} {lbrace}
{proofAnchors}
{rbrace}"

/-- Generate partial round S-box (applies only to first element) -/
def genPartialRoundSbox (config : CodeGenConfig) : String :=
  let ft := config.fieldType
  let t := config.stateSize
  let exp := config.sboxExp

  let header := s!"/**
 * Partial round S-box: apply x^{exp} only to state[0]
 * Used in middle RP rounds of Poseidon2
 *
 * @param state  Poseidon state (modified in place)
 * @param p      Field parameters
 */"

  let signature := s!"void sbox{exp}_partial_round(
    poseidon_state_{t} *state,
    const field_params *p
)"

  let body := match ft with
    | .BN254 => s!"    sbox{exp}(state->elem[0], state->elem[0], p);"
    | .Goldilocks => s!"    state->elem[0] = sbox{exp}(state->elem[0]);"
    | .Generic => s!"    sbox{exp}(state->elem[0], state->elem[0], p);"

  let proofAnchors := if config.includeProofAnchors then
    s!"    {proofAnchor "PRE: state contains valid field elements"}\n{body}\n    {proofAnchor "POST: state[0] = state[0]^exp, state[1..t-1] unchanged"}"
  else body

  s!"{header}
{signature} {lbrace}
{proofAnchors}
{rbrace}"

/-! ## Part 6: Header and Type Definitions -/

/-- Generate type definitions for Poseidon state -/
def genTypeDefs (config : CodeGenConfig) : String :=
  let ft := config.fieldType
  let t := config.stateSize

  let fieldElemType := match ft with
    | .BN254 => s!"uint64_t elem[{t}][{limbCount ft}]"
    | .Goldilocks => s!"uint64_t elem[{t}]"
    | .Generic => s!"uint64_t elem[{t}][{limbCount ft}]"

  s!"/**
 * Poseidon state with {t} field elements
 */
typedef struct {lbrace}
    {fieldElemType};
{rbrace} poseidon_state_{t};

/**
 * Field parameters (for Montgomery arithmetic)
 */
typedef struct {lbrace}
    uint64_t modulus[{limbCount ft}];  // Prime modulus
    uint64_t r2[{limbCount ft}];       // R^2 mod p (for Montgomery)
    uint64_t inv;                       // -p^(-1) mod 2^64
{rbrace} field_params;"

/-! ## Part 7: Complete File Generation -/

/-- Generate complete C file with S-box functions -/
def genSboxCFile (config : CodeGenConfig) : String :=
  let header := s!"/**
 * Poseidon2 S-box Implementation
 * Generated by AMO-Lean Phase Poseidon (Paso 2.1)
 *
 * Field: {repr config.fieldType}
 * State size: {config.stateSize}
 * S-box exponent: {config.sboxExp}
 * Square chain multiplications: {squareChainMulCount config.sboxExp}
 *
 * This is SCALAR code - optimized SIMD versions are in separate files.
 * See ADR-004 for the layered CodeGen strategy.
 */

#ifndef POSEIDON_SBOX_H
#define POSEIDON_SBOX_H

#include <stdint.h>
#include <stddef.h>
"

  let externC := s!"#ifdef __cplusplus\nextern \"C\" {lbrace}\n#endif\n"
  let externCEnd := s!"\n#ifdef __cplusplus\n{rbrace}\n#endif\n"

  let typeDefs := genTypeDefs config
  let sboxFunc := genSboxFunction config
  let fullRound := genFullRoundSbox config
  let partialRound := genPartialRoundSbox config

  let footer := "\n#endif // POSEIDON_SBOX_H\n"

  s!"{header}
{externC}
/* ============================================================================
 * Type Definitions
 * ============================================================================ */

{typeDefs}

/* ============================================================================
 * Field Multiplication (External - implement in field_ops.c)
 * ============================================================================ */

/**
 * Field multiplication with Montgomery reduction
 * out = a * b mod p
 */
extern void field_mul(uint64_t *out, const uint64_t *a, const uint64_t *b,
                      const field_params *p);

/* ============================================================================
 * S-box Implementation
 * ============================================================================ */

{sboxFunc}

/* ============================================================================
 * Full Round S-box (all state elements)
 * ============================================================================ */

{fullRound}

/* ============================================================================
 * Partial Round S-box (first element only)
 * ============================================================================ */

{partialRound}

{externCEnd}{footer}"

/-! ## Part 8: Tests -/

section Tests

def testGenSbox5 : IO Unit := do
  IO.println "=== Test 1: Generate S-box for α=5 (BN254) ==="
  let config : CodeGenConfig := {
    fieldType := .BN254
    stateSize := 3
    sboxExp := 5
  }
  let code := genSboxCFile config
  IO.println code
  IO.println ""

def testGenSboxGoldilocks : IO Unit := do
  IO.println "=== Test 2: Generate S-box for α=7 (Goldilocks) ==="
  let config : CodeGenConfig := {
    fieldType := .Goldilocks
    stateSize := 12
    sboxExp := 7
  }
  let code := genSboxCFile config
  IO.println code
  IO.println ""

def testSquareChain : IO Unit := do
  IO.println "=== Test 3: Square chain analysis ==="
  for exp in [5, 7, 11] do
    let chain := optimalSquareChain exp
    let count := chain.length
    IO.println s!"  x^{exp}: {count} multiplications"
    for (name, a, b) in chain do
      IO.println s!"    {name} = {a} * {b}"
  IO.println ""

-- Run tests
#eval! do
  testSquareChain
  testGenSbox5
  testGenSboxGoldilocks

end Tests

end AmoLean.Protocols.Poseidon.CodeGen
