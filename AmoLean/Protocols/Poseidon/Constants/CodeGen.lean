/-
  Poseidon2 Constants Code Generation

  Generates C source files with round constants and MDS matrices.

  Key design decisions:
  1. Constants are generated in STANDARD form (not Montgomery)
     - The C code converts to Montgomery at initialization time
     - This is clearer and matches the reference implementation
  2. Single source of truth: constants come from BN254.lean
  3. Layout: RC[round][elem][limb] for cache-friendly access
-/

import AmoLean.Protocols.Poseidon.Constants.BN254

namespace AmoLean.Protocols.Poseidon.Constants.CodeGen

open AmoLean.Protocols.Poseidon.Constants.BN254

/-! ## Utility Functions -/

/-- Convert a 256-bit number to 4 64-bit limbs (little-endian) -/
def toLimbs (n : Nat) : Array UInt64 :=
  let mask := (1 <<< 64) - 1
  #[
    UInt64.ofNat (n &&& mask),
    UInt64.ofNat ((n >>> 64) &&& mask),
    UInt64.ofNat ((n >>> 128) &&& mask),
    UInt64.ofNat ((n >>> 192) &&& mask)
  ]

/-- Format a UInt64 as hex for C code -/
def formatHex (n : UInt64) : String :=
  let hex := String.mk (Nat.toDigits 16 n.toNat)
  let padded := String.mk (List.replicate (16 - hex.length) '0') ++ hex
  s!"0x{padded}ULL"

/-- Format limbs as C array initializer -/
def formatLimbs (limbs : Array UInt64) : String :=
  let formatted := limbs.toList.map formatHex
  "{" ++ String.intercalate ", " formatted ++ "}"

/-- Format a field element as C array initializer -/
def formatElement (n : Nat) : String :=
  formatLimbs (toLimbs n)

/-! ## C Code Generation -/

def lbrace : String := "{"
def rbrace : String := "}"

/-- Generate the MDS matrix as C code -/
def genMDSMatrix : String :=
  let rows := MDS.map fun row =>
    let elems := row.map formatElement
    "    {" ++ String.intercalate ", " elems ++ "}"
  s!"// MDS Matrix (3x3) - standard form
const uint64_t POSEIDON_MDS_3[3][3][4] = {lbrace}
{String.intercalate ",\n" rows}
{rbrace};"

/-- Generate the diagonal matrix for internal MDS -/
def genMDSDiag : String :=
  let elems := MDS_DIAG.map formatElement
  s!"// MDS Diagonal for internal rounds
const uint64_t POSEIDON_MDS_DIAG_3[3][4] = {lbrace}
    {String.intercalate ",\n    " elems}
{rbrace};"

/-- Generate all round constants -/
def genRoundConstants : IO String := do
  let mut lines : Array String := #[]
  lines := lines.push "// Round constants (64 rounds x 3 elements x 4 limbs)"
  lines := lines.push s!"const uint64_t POSEIDON_RC_3[64][3][4] = {lbrace}"

  for round in [:RC.size] do
    let roundConsts := RC[round]!
    let mut elemStrs : Array String := #[]
    for elem in [:3] do
      let val := roundConsts[elem]!
      elemStrs := elemStrs.push (formatElement val)
    let roundStr := "    {" ++ String.intercalate ", " elemStrs.toList ++ "}"
    let comma := if round < RC.size - 1 then "," else ""
    let comment := if round < 4 then " // full round"
                   else if round >= 60 then " // full round"
                   else " // partial round"
    lines := lines.push (roundStr ++ comma ++ comment)

  lines := lines.push s!"{rbrace};"
  return String.intercalate "\n" lines.toList

/-- Generate the complete constants C file -/
def genConstantsFile : IO String := do
  let rcCode ← genRoundConstants
  return s!"/**
 * Poseidon2 Constants for BN254 (t=3)
 *
 * Generated by AMO-Lean Phase 4a
 * Source: HorizenLabs/poseidon2
 *
 * Configuration:
 *   Field: BN254 (prime = 21888242871839275222246405745257275088548364400416034343698204186575808495617)
 *   State size: t = 3
 *   S-box: x^5
 *   Rounds: RF = 8, RP = 56 (total = 64)
 *
 * Format: Constants are in STANDARD form (not Montgomery).
 *         Convert to Montgomery form at initialization if needed.
 *
 * Test Vector:
 *   Input:  [0, 1, 2]
 *   Output: [0x0bb61d24daca55eebcb1929a82650f328134334da98ea4f847f760054f4a3033,
 *            0x303b6f7c86d043bfcbcc80214f26a30277a15d3f74ca654992defe7ff8d03570,
 *            0x1ed25194542b12eef8617361c3ba7c52e660b145994427cc86296242cf766ec8]
 */

#ifndef POSEIDON_CONSTANTS_H
#define POSEIDON_CONSTANTS_H

#include <stdint.h>

/* ============================================================================
 * Field Parameters
 * ============================================================================ */

// BN254 prime modulus (4 x 64-bit limbs, little-endian)
static const uint64_t BN254_MODULUS[4] = {lbrace}
    0x43e1f593f0000001ULL,
    0x2833e84879b97091ULL,
    0xb85045b68181585dULL,
    0x30644e72e131a029ULL
{rbrace};

// R^2 mod p (for Montgomery conversion)
static const uint64_t BN254_R2[4] = {lbrace}
    0x1bb8e645ae216da7ULL,
    0x53fe3ab1e35c59e3ULL,
    0x8c49833d53bb8085ULL,
    0x0216d0b17f4e44a5ULL
{rbrace};

// Montgomery inverse: -p^(-1) mod 2^64
static const uint64_t BN254_INV = 0xc2e1f593efffffffULL;

/* ============================================================================
 * MDS Matrices
 * ============================================================================ */

{genMDSMatrix}

{genMDSDiag}

/* ============================================================================
 * Round Constants
 * ============================================================================ */

{rcCode}

/* ============================================================================
 * Initialization (Convert to Montgomery form)
 * ============================================================================ */

// Call this once at startup to convert constants to Montgomery form
// (Implementation in poseidon_init.c)
void poseidon_init_constants(void);

#endif // POSEIDON_CONSTANTS_H
"

/-- Write the constants file to disk -/
def writeConstantsFile (path : String) : IO Unit := do
  let content ← genConstantsFile
  IO.FS.writeFile path content
  IO.println s!"Written: {path}"

/-! ## Test -/

#eval do
  -- Generate and print a preview
  let content ← genConstantsFile
  IO.println (content.take 3000)
  IO.println "..."
  IO.println s!"Total size: {content.length} characters"

end AmoLean.Protocols.Poseidon.Constants.CodeGen
