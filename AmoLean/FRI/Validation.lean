/-
  AMO-Lean: FRI Fold Validation
  Phase 0 - Translation Validation via Test Vectors

  This module implements translation validation per DD-005:
  1. Execute spec in Lean → result_lean
  2. Generate test vectors (inputs + expected outputs)
  3. C code reads test vectors and compares

  This approach is simpler than FFI for Phase 0 PoC while still
  validating that generated code produces correct results.

  For production, consider FFI-based validation where Lean calls
  compiled C directly.
-/

import AmoLean.FRI.FoldExpr
import AmoLean.FRI.Fold
import AmoLean.Vector.Basic

namespace AmoLean.FRI.Validation

open AmoLean.FRI.FoldExpr (foldDirect)
open AmoLean.FRI.Fold (FRIField)
open AmoLean.Vector (Vec)

/-! ## Part 1: Test Vector Generation -/

/-- A test case for FRI fold validation -/
structure FoldTestCase where
  /-- Test name -/
  name : String
  /-- Size of vectors -/
  size : Nat
  /-- Even input values -/
  even : List UInt64
  /-- Odd input values -/
  odd : List UInt64
  /-- Alpha value -/
  alpha : UInt64
  /-- Expected output values -/
  expected : List UInt64
  deriving Repr, Inhabited

/-- Generate a test case using Lean computation -/
def generateTestCase (name : String) (size : Nat)
    (evenVals oddVals : List UInt64) (alpha : UInt64) : FoldTestCase :=
  -- Compute expected result using native Lean arithmetic
  let expected := List.zipWith (fun e o => e + alpha * o) evenVals oddVals
  { name, size, even := evenVals, odd := oddVals, alpha, expected }

/-! ## Part 2: C Test Vector File Generation -/

/-- Format a list of UInt64 as C array initializer -/
def formatCArray (vals : List UInt64) : String :=
  let inner := vals.map (s!"{·}") |>.intersperse ", " |> String.join
  s!"\{{inner}}"

/-- Generate C code for a single test case -/
def testCaseToC (tc : FoldTestCase) : String :=
  let evenArr := formatCArray tc.even
  let oddArr := formatCArray tc.odd
  let expectedArr := formatCArray tc.expected
  s!"    // Test: {tc.name}
    \{
        .name = \"{tc.name}\",
        .size = {tc.size},
        .even = {evenArr},
        .odd = {oddArr},
        .alpha = {tc.alpha},
        .expected = {expectedArr}
    },"

/-- Generate complete C validation test file -/
def generateValidationTestC (testCases : List FoldTestCase) : String :=
  let casesStr := testCases.map testCaseToC |>.intersperse "\n" |> String.join
  s!"/**
 * fri_fold_validation.c - Validation Test for Generated FRI Fold
 *
 * This file contains test vectors generated by Lean to validate
 * that the generated C code produces correct results.
 *
 * Generated by: AmoLean.FRI.Validation
 * Design Decision: DD-005 (Translation Validation)
 *
 * Compile:
 *   clang -DFIELD_NATIVE -DDEBUG -fsanitize=address,undefined \\
 *         -I. -o fri_validation fri_fold_validation.c
 *
 * Run:
 *   ./fri_validation
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>

/* Define via compiler flags: -DFIELD_NATIVE -DDEBUG
 * or uncomment below for standalone compilation */
#ifndef FIELD_NATIVE
#define FIELD_NATIVE
#endif
#ifndef DEBUG
#define DEBUG
#endif

#include \"field_ops.h\"
#include \"fri_fold.h\"

#define MAX_SIZE 1024

typedef struct \{
    const char* name;
    size_t size;
    uint64_t even[MAX_SIZE];
    uint64_t odd[MAX_SIZE];
    uint64_t alpha;
    uint64_t expected[MAX_SIZE];
} TestCase;

static const TestCase test_cases[] = \{
{casesStr}
};

static const size_t NUM_TESTS = sizeof(test_cases) / sizeof(test_cases[0]);

int run_test(const TestCase* tc) \{
    printf(\"  Testing: %s (size=%zu)\\n\", tc->name, tc->size);

    uint64_t* output = malloc(tc->size * sizeof(uint64_t));
    if (!output) \{
        printf(\"    FAIL: Memory allocation failed\\n\");
        return 0;
    }

    // Run the generated FRI fold
    fri_fold(tc->size, tc->even, tc->odd, output, tc->alpha);

    // Compare with expected
    int pass = 1;
    for (size_t i = 0; i < tc->size; i++) \{
        if (output[i] != tc->expected[i]) \{
            printf(\"    FAIL at index %zu: got %llu, expected %llu\\n\",
                   i, (unsigned long long)output[i],
                   (unsigned long long)tc->expected[i]);
            pass = 0;
        }
    }

    free(output);

    if (pass) \{
        printf(\"    PASS\\n\");
    }
    return pass;
}

int main(void) \{
    printf(\"╔══════════════════════════════════════════════════════════════╗\\n\");
    printf(\"║     FRI FOLD VALIDATION (Lean → C)                           ║\\n\");
    printf(\"╚══════════════════════════════════════════════════════════════╝\\n\");
    printf(\"Field: %s\\n\\n\", FIELD_NAME);

    int all_pass = 1;
    size_t passed = 0;

    for (size_t i = 0; i < NUM_TESTS; i++) \{
        if (run_test(&test_cases[i])) \{
            passed++;
        } else \{
            all_pass = 0;
        }
    }

    printf(\"\\n\");
    printf(\"Results: %zu/%zu tests passed\\n\", passed, NUM_TESTS);

    if (all_pass) \{
        printf(\"══════════════════════════════════════════════════════════════\\n\");
        printf(\"VALIDATION PASSED: Generated C matches Lean spec\\n\");
        printf(\"══════════════════════════════════════════════════════════════\\n\");
        return 0;
    } else \{
        printf(\"══════════════════════════════════════════════════════════════\\n\");
        printf(\"VALIDATION FAILED: Discrepancy between Lean and C\\n\");
        printf(\"══════════════════════════════════════════════════════════════\\n\");
        return 1;
    }
}
"

/-! ## Part 3: Predefined Test Cases -/

/-- Helper to generate a range as UInt64 list -/
def rangeU64 (n : Nat) : List UInt64 :=
  List.range n |>.map (·.toUInt64)

/-- Helper to generate a range with a function applied -/
def rangeMapU64 (n : Nat) (f : Nat → Nat) : List UInt64 :=
  List.range n |>.map (fun i => (f i).toUInt64)

/-- Standard test cases covering various sizes -/
def standardTestCases : List FoldTestCase := [
  -- Test 1: Small vector (n=4)
  generateTestCase "small_n4" 4
    [1, 2, 3, 4]
    [10, 20, 30, 40]
    2,

  -- Test 2: Alpha = 0 (should return even)
  generateTestCase "alpha_zero" 4
    [100, 200, 300, 400]
    [1, 2, 3, 4]
    0,

  -- Test 3: Alpha = 1 (should return even + odd)
  generateTestCase "alpha_one" 4
    [10, 20, 30, 40]
    [1, 2, 3, 4]
    1,

  -- Test 4: Medium vector (n=16)
  generateTestCase "medium_n16" 16
    (rangeMapU64 16 (· + 1))
    (rangeMapU64 16 (fun i => (i + 1) * 10))
    3,

  -- Test 5: Larger vector (n=64)
  generateTestCase "larger_n64" 64
    (rangeU64 64)
    (rangeMapU64 64 (fun i => 64 - i))
    7,

  -- Test 6: Power of 2 boundary (n=256)
  generateTestCase "power2_n256" 256
    (rangeMapU64 256 (· * 2))
    (rangeMapU64 256 (· * 3))
    5
]

/-! ## Part 4: Generation Command -/

/-- Generate and write the validation test file -/
def generateValidationFile (path : String) : IO Unit := do
  let content := generateValidationTestC standardTestCases
  IO.FS.writeFile path content
  IO.println s!"Generated: {path}"
  IO.println s!"Test cases: {standardTestCases.length}"

/-! ## Part 5: Tests -/

section Tests

#eval! do
  IO.println "╔══════════════════════════════════════════════════════════════╗"
  IO.println "║     FRI VALIDATION TEST GENERATION                           ║"
  IO.println "╚══════════════════════════════════════════════════════════════╝"
  IO.println ""

  IO.println s!"Standard test cases: {standardTestCases.length}"
  for tc in standardTestCases do
    IO.println s!"  - {tc.name} (n={tc.size})"

  IO.println ""
  IO.println "Test case 1 details:"
  let tc1 := standardTestCases[0]!
  IO.println s!"  even: {tc1.even}"
  IO.println s!"  odd: {tc1.odd}"
  IO.println s!"  alpha: {tc1.alpha}"
  IO.println s!"  expected: {tc1.expected}"

end Tests

end AmoLean.FRI.Validation
